.. seq:module:: ..random

:seq:mod:`..random`
-------------------

Source code: `random.seq <https://github.com/seq-lang/seq/blob/master/stdlib/./random.seq>`_

.. seq:data:: N



.. seq:data:: M



.. seq:data:: LOG4



.. seq:data:: NV_MAGICCONST



.. seq:data:: SG_MAGICCONST



.. seq:data:: TWOPI



.. seq:class:: RandomGenerator

   **Magic methods:**

      .. seq:method:: __init__()
         :noindex:

   **Methods:**

      .. seq:method:: gettimeofday()

      .. seq:method:: init_genrand(s : u32)

            
                    init_genrand(u32) -> void
            
                    initializes state[N] with a seed
            


      .. seq:method:: init_by_array(init_key : Array[u32], key_length : int)

            
                    initialize by an array with array-length
                    init_key is the array for initializing keys
                    key_length is its length
            


      .. seq:method:: genrand_int32()

            
                    genrand_int32() -> u32
            
                    generates a random number on [0,0xffffffff]-interval
            


      .. seq:method:: genrand_res53()

            
                    genrand_res53() -> float
            
                    generates a random number on [0,1) with 53-bit resolution
            


      .. seq:method:: random_seed_time_pid()

            
                    helper method for seed()
            


      .. seq:method:: seed()

            
                    Initialize internal state from hashable object.
            
                    For now a is set to its defaults a = None
            




.. seq:class:: Random

   **Magic methods:**

      .. seq:method:: __init__(g : RandomGenerator)
         :noindex:

            
                    Initialize an instance.
            
                    Optional argument x controls seeding, as for Random.seed().
            
                    For now x is set to its default None.
            


   **Methods:**

      .. seq:method:: seed()

            
                    Initialize internal state from hashable object.
            
                    None or no argument seeds from current time or from an operating
                    system specific randomness source if available.
            
                    If *a* is an int, all bits are used.
            
                    For version 2 (the default), all of the bits are used if *a* is a str,
                    bytes, or bytearray.  For version 1 (provided for reproducing random
                    sequences from older versions of Python), the algorithm for str and
                    bytes generates a narrower range of seeds.
            
                    For now a is set to its defaults a = None
            


      .. seq:method:: from_bytes_big(b)

            
                    Return the integer represented by the given array of bytes.
                    The argument b must either be a bytes-like object or an iterable
                    producing bytes.
            


      .. seq:method:: getrandbits(k : int)

            
                    getrandbits(k) -> x
                    Generates an int with k random bits.
            


      .. seq:method:: bit_length(n : int)

            
            


      .. seq:method:: randrange(start : int, stop : int, step : int)

            
                    Choose a random item from range(start, stop[, step]).
            
                    Return a randomly selected element from range(start, stop, step).
                    This is equivalent to choice(range(start, stop, step)), but
                    doesnâ€™t actually build a range object.
            
                    For now stop == 0 for randrange(stop) where start = stop in our parameter.
                    Defaults include: stop = None, step = 1
                    for now we will use default value for step.
            


      .. seq:method:: randint(a : int, b : int)

            
                    Return random integer in range [a, b], including both end points.
            


      .. seq:method:: random()

            
                    random(self) -> float
            
                    Return the next random floating point number in the range [0.0, 1.0).
            


      .. seq:method:: choice[T](sequence : Generator[T])

            
                    Choose a random element from a non-empty sequence.
            


      .. seq:method:: shuffle(x)

            
                    Shuffle list x in place, and return None.
            
                    Optional argument random is a 0-argument function returning a
                    random float in [0.0, 1.0); if it is the default None, the
                    standard random.random will be used.
            
                    For now seq will use random = 0  (None = default)
            


      .. seq:method:: uniform(a, b)

            
                    Get a random number in the range [a, b) or [a, b] depending on rounding.
            


      .. seq:method:: triangular(low : float, high : float, mode : float)

            
                    Triangular distribution.
            
                    Continuous distribution bounded by given lower and upper limits,
                    and having a given mode value in-between.
            
                    http://en.wikipedia.org/wiki/Triangular_distribution
            
                    For now we mode to default: mode = None
                    default for low and high : low = 0.0, high = 1.0
            


      .. seq:method:: gammavariate(alpha : float, beta : float)

            
                    Gamma distribution.  Not the gamma function!
            
                    Conditions on the parameters are alpha > 0 and beta > 0.
            
                    The probability distribution function is:
            
                    ::
            
                                x ** (alpha - 1) * math.exp(-x / beta)
                      pdf(x) =  --------------------------------------
                                  math.gamma(alpha) * beta ** alpha
            


      .. seq:method:: betavariate(alpha : float, beta : float)

            
                    Beta distribution.
                    Conditions on the parameters are alpha > 0 and beta > 0.
                    Returned values range between 0 and 1.
            


      .. seq:method:: expovariate(lambd : float)

            
                    Exponential distribution.
            
                    lambd is 1.0 divided by the desired mean.  It should be
                    nonzero.
            
                    Returned values range from 0 to
                    positive infinity if lambd is positive, and from negative
                    infinity to 0 if lambd is negative.
            


      .. seq:method:: gauss(mu : float, sigma : float)

            
                    Gaussian distribution.
            
                    mu is the mean, and sigma is the standard deviation.  This is
                    slightly faster than the normalvariate() function.
                    Not thread-safe without a lock around calls.
            


      .. seq:method:: paretovariate(alpha : float)

            
                    Pareto distribution.  alpha is the shape parameter.


      .. seq:method:: weibullvariate(alpha : float, beta : float)

            
                    Weibull distribution.
            
                    alpha is the scale parameter and beta is the shape parameter.
            


      .. seq:method:: normalvariate(mu : float, sigma : float)

            
                    Normal distribution.
            
                    mu is the mean, and sigma is the standard deviation.
            


      .. seq:method:: lognormvariate(mu : float, sigma : float)

            
                      Log normal distribution.
            
                      If you take the natural logarithm of this distribution, you'll get a
                      normal distribution with mean mu and standard deviation sigma.
                      mu can have any value, and sigma must be greater than zero.
            


      .. seq:method:: vonmisesvariate(mu : float, kappa : float)

            
                    Circular data distribution.
            
                    mu is the mean angle, expressed in radians between 0.0 and 2*pi, and
                    kappa is the concentration parameter, which must be greater than or
                    equal to zero.  If kappa is equal to zero, this distribution reduces
                    to a uniform random angle over the range 0.0 to 2*pi.
            


      .. seq:method:: sample[T](population : List[T], k : int)

            
                    Chooses k unique random elements from a population sequence or set.
            
                    Returns a new list containing elements from the population while
                    leaving the original population unchanged.  The resulting list is
                    in selection order so that all sub-slices will also be valid random
                    samples.  This allows raffle winners (the sample) to be partitioned
                    into grand prize and second place winners (the subslices).
            
                    Members of the population need not be hashable or unique.  If the
                    population contains repeats, then each occurrence is a possible
                    selection in the sample.
            
                    To choose a sample in a range of integers, use range as an argument.
                    This is especially fast and space efficient for sampling from a
                    large population:   sample(range(10000000), 60)
            
                    For now seq will deal with only lists.
            


      .. seq:method:: choices(population, weights : Optional[List[int]], cum_weights : Optional[List[int]], k : int)

            
                    Return a k sized list of population elements chosen with replacement.
            
                    If the relative weights or cumulative weights are not specified,
                    the selections are made with equal probability.
            
                    Since weights and cum_weights is assumed to be positive, we will replace None with [-1].
            




.. seq:function:: seed(a : int)



.. seq:function:: getrandbits(k : int)



.. seq:function:: randrange(start : int, stop : Optional[int] = None, step : int = 1)



.. seq:function:: randint(a : int, b : int)



.. seq:function:: choice(s)



.. seq:function:: choices(population, weights : Optional[List[int]] = None, cum_weights : Optional[List[int]] = None, k : int = 1)



.. seq:function:: shuffle(s)



.. seq:function:: sample(population, k : int)



.. seq:function:: random()



.. seq:function:: uniform(a, b)



.. seq:function:: triangular(low : float = 0.0, high : float = 1.0, mode : Optional[float] = None)



.. seq:function:: betavariate(alpha : float, beta : float)



.. seq:function:: expovariate(lambd : float)



.. seq:function:: gammavariate(alpha : float, beta : float)



.. seq:function:: gauss(mu : float, sigma : float)



.. seq:function:: lognormvariate(mu : float, sigma : float)



.. seq:function:: normalvariate(mu : float, sigma : float)



.. seq:function:: vonmisesvariate(mu : float, kappa : float)



.. seq:function:: paretovariate(alpha : float)



.. seq:function:: weibullvariate(alpha : float, beta : float)





