@extend
class int:
    def __int__(self) -> int:
        assert False
        return 0
    def __float__(self) -> float:
        assert False
        return 0.0
    def __bool__(self) -> bool:
        assert False
        return False
    def __pos__(self) -> int:
        assert False
        return self
    def __neg__(self) -> int:
        assert False
        return 0 - self
    def __lshift__(self, other: int) -> int:
        assert False
        return self
    def __rshift__(self, other: int) -> int:
        assert False
        return self
    def __add__(self, b: int) -> int:
        assert False
        return self
    def __add__(self, other: float) -> float:
        assert False
        return self
    def __sub__(self, b: int) -> int:
        assert False
        return self
    def __sub__(self, other: float) -> float:
        assert False
        return self
    def __mul__(self, b: int) -> int:
        assert False
        return self
    def __mul__(self, other: float) -> float:
        assert False
        return self
    def __floordiv__(self, b: int) -> int:
        assert False
        return self
    def __floordiv__(self, other: float) -> float:
        assert False
        return self
    def __truediv__(self, other: int) -> float:
        assert False
        return self
    def __truediv__(self, other: float) -> float:
        assert False
        return self
    def __mod__(self, b: int) -> int:
        assert False
        return self
    def __mod__(self, other: float) -> float:
        assert False
        return self
    def __invert__(self) -> int:
        assert False
        return self
    def __and__(self, b: int) -> int:
        assert False
        return self
    def __or__(self, b: int) -> int:
        assert False
        return self
    def __xor__(self, b: int) -> int:
        assert False
        return self
    def __shr__(self, b: int) -> int:
        assert False
        return self
    def __shl__(self, b: int) -> int:
        assert False
        return self
    def __eq__(self, b: int) -> bool:
        assert False
        return True
    def __eq__(self, b: float) -> bool:
        assert False
        return True
    def __ne__(self, b: int) -> bool:
        assert False
        return True
    def __ne__(self, b: float) -> bool:
        assert False
        return True
    def __lt__(self, b: int) -> bool:
        assert False
        return True
    def __lt__(self, b: float) -> bool:
        assert False
        return True
    def __gt__(self, b: int) -> bool:
        assert False
        return True
    def __gt__(self, b: float) -> bool:
        assert False
        return True
    def __le__(self, b: int) -> bool:
        assert False
        return True
    def __le__(self, b: float) -> bool:
        assert False
        return True
    def __ge__(self, b: int) -> bool:
        assert False
        return True
    def __ge__(self, b: float) -> bool:
        assert False
        return True
    def __pow__(self, exp: int):
        assert False
        return True

@extend
class float:
    def __int__(self) -> int:
        assert False
        return 0
    def __float__(self) -> float:
        assert False
        return 0.0
    def __bool__(self) -> bool:
        assert False
        return False

@extend
class bool:
    def __int__(self) -> int:
        assert False
        return 0
    def __float__(self) -> float:
        assert False
        return 0.0
    def __bool__(self) -> bool:
        assert False
        return False

@llvm
def eq(a: int, b: int) -> bool:
    %tmp = icmp eq i64 %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

def foo(x):
  return x

@test
def test_int_simple_fold():
  x = 1
  y = x + 2
  z = x + 3
  assert eq(foo(x + 1), 2)
  assert eq(foo(y * 2), 6)
  assert eq(foo(z // 3), 1)
  assert eq(foo(x >> 2), 0)
  assert eq(foo(x << y), 8)
  assert eq(foo(x | y), 3)
  assert eq(foo(z & z), 4)
  assert not foo(x > y)
  assert foo(y < z)
  assert not foo(x >= z)
  assert foo(x <= 2)
  assert foo(x == 1)
  assert foo(x != 2)
test_int_simple_fold()

@test
def test_ternary_fold():
  x = 1
  y = x * 2
  assert (x + 1 if x != 0 else -1) > 0
  assert (x + 1 if x == 0 else -1) < 0
test_ternary_fold()

@test
def test_try_catch_fold():
  x = 0
  y = x + 1
  try:
      x = 1
  finally:
    x = 4
  assert x == 4
test_try_catch_fold()

@test
def test_while_fold():
  x = 0
  y = 1
  while (x != 0):
    y = 2
  assert y + 1 == 2
test_while_fold()

@test
def test_imperative_for_fold():
  foo = 2
  y = 1
  for i in range(foo, 2):
    y = foo - 1
  assert y == 1
test_imperative_for_fold()

@test
def test_long_fold():
  x = 3
  assert eq(foo(x + x + x + x + x + x + x + x + x + x + x + x), 36)
test_long_fold()

@test
def test_conversions():
  n = 42
  b = True
  x = 3.14

  assert eq(foo(n.__int__()), n)
  assert foo(n.__float__()) == 42.0
  assert foo(n.__bool__())

  assert eq(foo(b.__int__()), 1)
  assert foo(b.__float__()) == 1.0
  assert foo(b.__bool__())

  assert eq(foo(x.__int__()), 3)
  assert foo(x.__float__()) == x
  assert foo(x.__bool__())
test_conversions()

@test
def test_no_ops():
  def v(): return 42
  n = v()
  assert eq(+n, n)
  assert eq(-(-n), n)
  assert eq(~(~n), n)
test_no_ops()

@test
def test_algebraic_simplification():
  def v(): return 42
  n = v()
  assert eq(0*n, 0)
  assert eq(n*0, 0)
  assert eq(n*1, n)
  assert eq(1*n, n)
  assert eq(n+0, n)
  assert eq(0+n, n)
  assert eq(n-0, n)
  assert eq(0//n, 0)
test_algebraic_simplification()
