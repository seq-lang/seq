#%% basic,barebones
a = 5
b: float = 6.16
c: optional[str] = None
print a, b, c  #: 5 6.16 None

#%% late_unify,barebones
a = []
a.append(1)
print a  #: [1]

#%% late_unify_2,barebones
class XX[T]:
    y: T
a = XX()
def f(i: int) -> int:
    return i
print a.y.__class__ #: int
f(a.y)
print a.__class__ #: XX[int]
print XX[bool].__class__ #: XX[bool]

#%% nested_generic,barebones
x = Array[Array[int]](0)
f = Optional[Optional[Optional[int]]](Optional[Optional[int]](Optional[int](5)))
print x.len, f  #: 0 5

#%% map_unify
def map[T,S](l: list[T], f: Callable[S,T]):
    return [f(x) for x in l]
e = 1
print map([1, 2, 3], lambda x: x+e)  #: [2, 3, 4]

#%% nested,barebones
def m4[TD](a: int, d: TD):
    def m5[TE](a: int, d: TD, e: TE):
        print a, d, e
    m5(a, d, 1.12)
m4(1, 's')  #: 1 s 1.12
m4(1, True)  #: 1 True 1.12

#%% nested_class,barebones
class A[TA]:
    a: TA
    # lots of nesting:
    def m4[TD](self: A[TA], d: TD):
        def m5[TE](a: TA, d: TD, e: TE):
            print a, d, e
        m5(self.a, d, d)
ax = A(42)
ax.m4(1)  #: 42 1 1

#%% static_fn,barebones
class A[TA]:
    a: TA
    def dump(a, b, c):
        print a, b, c
    def m2():
        A.dump(1, 2, 's')
    def __str__(self):
        return 'A'
A.dump(1, 2, 3)  #: 1 2 3
A[int].m2()  #: 1 2 s
A.m2()  #: 1 2 s
c = A[str]('s')
c.dump('y', 1.1)  #: A y 1.1

#%% realization_big
class A[TA,TB,TC]:
    a: TA
    b: TB
    c: TC

    def dump(a, b, c):
        print a, b, c

    # non-generic method:
    def m0(self: A[TA,TB,TC], a: int):
        print a

    # basic generics:
    def m1[X](self: A[TA,TB,TC], other: A[X,X,X]):
        print other.a, other.b, other.c

    # non-generic method referencing outer generics:
    def m2(a: TA, b: TB, c: TC):
        A.dump(a, b, c)

    # generic args:
    def m3(self, other):
        return self.a

    # lots of nesting:
    def m4[TD](self: A[TA,TB,TC], d: TD):
        def m5[TE](a: TA, b: TB, c: TC, d: TD, e: TE):
            print a, b, c, d, e
        m5(self.a, self.b, self.c, d, d)

    # instantiating the type:
    def m5(self):
        x = A(self.a, self.b, self.c)
        A.dump(x.a, x.b, x.c)

    # deeply nested generic type:
    def m6[T](v: array[array[array[T]]]):
        return v[0][0][0]
a1 = A(42, 3.14, "hello")
a2 = A(1, 2, 3)
a1.m1(a2)                           #: 1 2 3
A[int,float,str].m2(1, 1.0, "one")  #: 1 1 one
A[int,int,int].m2(11, 22, 33)       #: 11 22 33
print a1.m3(a2)                     #: 42
print a1.m3(a2)                     #: 42
print a2.m3(a1)                     #: 1
a1.m4(True)                         #: 42 3.14 hello True True
a1.m4([1])                          #: 42 3.14 hello [1] [1]
a2.m4("x")                          #: 1 2 3 x x
a1.m5()                             #: 42 3.14 hello
a2.m5()                             #: 1 2 3

v1 = array[array[array[str]]](1)
v2 = array[array[str]](1)
v3 = array[str](1)
v1[0] = v2
v2[0] = v3
v3[0] = "world"
print A.m6(v1)                      #: world

f = a2.m0
f(99)                               #: 99

#%% realization_small,barebones
class B1[T]:
    a: T
    def foo[S](self: S) -> B1[int]:
        return B1[int](111)
b1 = B1[bool](True).foo()
print b1.foo().a                    #: 111

class B2[T]:
    a: T
    def foo[S](self: B2[S]):
        return B2[int](222)
b2 = B2[str]("x").foo()
print b2.foo().a                    #: 222

# explicit realization:
def m7[T,S]():
    print "works"
m7[str,float]()                     #: works
m7[str,float]()                     #: works
m7[float,str]()                     #: works

#%% recursive,barebones
def foo(a):
    if not a:
        foo(True)
    print a
foo(0)
#: True
#: 0

def bar(a):
    def baz(x):
        if not x:
            bar(True)
        print (x)
    baz(a)
bar(0)
#: True
#: 0

def rec2(x, y):
    if x:
        return rec2(y, x)
    else:
        return 1.0
print rec2(1, False).__class__ #: float

def pq(x):
    return True
def rec3(x, y):
    if pq(x):
        return rec3(y, x)
    else:
        return y
print rec3('x', 's').__class__  #: str

# Nested mutually recursive function
def f[T](x: T) -> T:
    def g(z):
        return z(T())
    return g(f[T])
print f(1.2).__class__ #: float
print f('s').__class__ #: str

def f[T](x: T):
    return f[T](x - 1) if x else 1
print f(1) #: 1
print f(1.1).__class__ #: int


#%% recursive_error,barebones
def pq(x):
    return True
def rec3(x, y): #- ('a, 'b) -> 'b
    if pq(x):
        return rec3(y, x)
    else:
        return y
rec3(1, 's')
#!   ERROR: cannot unify int and str
#!   ERROR: while realizing rec3 (arguments rec3[int,int,str])

#%% instantiate_function_error,barebones
def fx[T](x: T) -> T:
    def g(z):
        return z(T())
    return g(fx)
fx(1)
#!   ERROR: cannot resolve 1 unbound variables
#!   ERROR: while realizing fx (arguments fx[int;int,int])

#%% optionals,barebones
y = None
print y  #: None
y = 5
print y  #: 5

def foo(x: optional[int], y: int):
    print 'foo', x, y
foo(y, 6)  #: foo 5 6
foo(5, 6)  #: foo 5 6
foo(5, y)  #: foo 5 5
y = None
try:
    foo(5, y)
except ValueError:
    print 'unwrap failed'  #: unwrap failed


#%% optional_methods,barebones
@extend
class int:
    def x(self):
        print 'x()!', self

y = None
z = 1 if y else None
print z  #: None

y = 6
z = 1 + y if y else None
print z  #: 7
z.x()  #: x()! 7
z = None
try:
    z.x()
except ValueError:
    print 'unwrap failed'  #: unwrap failed


#%% global_none,barebones
a, b = None, None
def foo():
    global a, b
    a = [1, 2]
    b = 3
print a, b,
foo()
print a, b #: None None [1, 2] 3

#%% default_type_none
class Test:
    value: int
    def __init__(self, value: int):
        self.value = value
    def __str__(self):
        return str(self.value)
def key_func(k: Test):
    return k.value
print sorted([Test(1), Test(3), Test(2)], key=key_func)  #: [1, 2, 3]
print sorted([Test(1), Test(3), Test(2)], key=lambda x: x.value)  #: [1, 2, 3]
print sorted([1, 3, 2])  #: [1, 2, 3]

#%% nested_map
print list(map(lambda i: i-2, map(lambda i: i+1, range(5))))
#: [-1, 0, 1, 2, 3]

def h(x: list[int]):
    return x
print h(list(map(lambda i: i-1, map(lambda i: i+2, range(5)))))
#: [1, 2, 3, 4, 5]

#%% func_unify_error,barebones
def foo(x:int):
    print x
z = 1 & foo #! ERROR: cannot unify foo[void,int] and int

#%% void_error,barebones
def foo():
    print 'foo'
def bar(x):
    print 'bar'
a = foo()
bar(a) #! ERROR: expression with void type

#%% void_error_2,barebones
def foo():
    i = 0
    while i < 10:
        print i
        yield
        i += 1
a = list(foo())
#!     ERROR: expression with void type
#!     ERROR: while realizing List.__init__.2
#!     ERROR: while realizing list

#%% instantiate_swap,barebones
class Foo[T, U]:
    t: T
    u: U
    def __init__(self):
        self.t = T()
        self.u = U()
    def __str__(self):
        return f'{self.t} {self.u}'
print Foo[int, bool](), Foo[bool, int]() #: 0 False False 0

#%% static,barebones
class Num[N_: int]:
    def __str__(self):
        return f'[{N_}]'
    def __init__(self):
        pass
def foo[N: int]():
    print Num[N*2]()
foo[3]() #: [6]

class XX[N_: int]:
    a: Num[N_*2]
    def __init__(self):
        self.a = Num()
y = XX[5]()
print y.a, y.__class__, y.a.__class__ #: [10] XX[5] Num[10]

@tuple
class FooBar[N: int]:
    x: Int[N]
z = FooBar(i32(5))
print z, z.__class__, z.x.__class__ #: (x: 5) FooBar[32] Int[32]

@tuple
class Foo[N: int]:
    x: Int[2*N]
    def __new__(x: Int[2*N]) -> Foo[N]:
        return (x,)
foo = Foo[10](Int[20](0))
print foo.__class__, foo.x.__class__ #: Foo[10] Int[20]

#%% static_2,barebones
class Num[N: int]:
    def __str__(self):
        return f'~{N}'
    def __init__(self):
        pass
class Foo[T, A: int, B: int]:
    a: Num[A+B]
    b: Num[A-B]
    c: Num[A if A > 3 else B]
    t: T
    def __init__(self):
        self.a = Num()
        self.b = Num()
        self.c = Num()
        self.t = T()
    def __str__(self):
        return f'<{self.a} {self.b} {self.c} :: {self.t}>'
print Foo[int, 3, 4](), Foo[int, 5, 4]()
#: <~7 ~-1 ~4 :: 0> <~9 ~1 ~5 :: 0>

#%% static_fail,barebones
def test(i: Int[32]):
    print int(i)
test(Int[5](1)) #! ERROR: cannot unify Int[5] and Int[32]

#%% static_fail_2,barebones
zi = Int[32](6)
def test3[N](i: Int[N]):
    print int(i)
test3(zi) #! ERROR: cannot unify
# TODO: nicer error message!

#%% static_fail_3,barebones
zi = Int[32](6)
def test3[N](i: Int[N]):
    print int(i)
test3[int](1) #! ERROR: cannot unify
# TODO: nicer error message!

#%% nested_fn_generic,barebones
def f(x):
    def g(y):
        return y
    return g(x)
print f(5), f('s') #: 5 s

def f[U](x: U, y):
    def g[T, U](x: T, y: U):
        return (x, y)
    return g(y, x)
x, y = 1, 'haha'
print f(x, y).__class__ #: Tuple.N2[str,int]
print f[str]('aa', 1.1).__class__ #: Tuple.N2[float,str]

#%% nested_fn_generic_error,barebones
def f[U](x: U, y): # ('u, 'a) -> tuple['a, 'u]
    def g[T, U](x: T, y: U): # ('t, 'u) -> tuple['t, 'u]
        return (x, y)
    return g(y, x)
print f[int](1.1, 1).__class__ #! ERROR: cannot unify float and int

#%% fn_realization,barebones
def f[T](x: T, y: tuple[T]):
      print f[str].__class__ #: Function.N2[str,str,Tuple.N1[str]]
      return x
x = f(1, (1,))
print x, x.__class__ #: 1 int
# print f.__class__  # TODO ERRORS

def f[T](x:T):
    def g(y):
        z = T()
        return z
    print f[str].__class__  #: Function.N1[void,str]
    print g(1).__class__ #: int
f(1)
print f(1).__class__ #: void

def f[T](x: T):
    print f[T](x).__class__  #: int
    print f(x).__class__      #: int
    print f[int](x).__class__ #: int
    return x
print f(1), f(1).__class__ #: 1 int
print f[int](1).__class__ #: int

#%% fn_realization_error,barebones
def f[T](x: T):
    print f[int](x).__class__
    return x
f('s')
#!   ERROR: cannot unify str and int
#!   ERROR: while realizing f

#%% nested_class_error,barebones
class X:
    def foo(self, x):
        return x
    class Y:
        def bar(self, x):
            return x
y = X.Y()
y.foo(1) #! ERROR: cannot find 'foo' in X.X.Y

#%% nested_deep_class,barebones
class A[T]:
    a: T
    class B[U]:
        b: U
        class C[V]:
            c: V
            def foo[W](t: V, u: V, v: V, w: W):
                return (t, u, v, w)

print A.B.C[bool].foo[str].__class__ #: Function.N4[Tuple.N4[bool,bool,bool,str],bool,bool,bool,str]
print A.B.C.foo(1,1,1,True) #: (1, 1, 1, True)
print A.B.C.foo('x', 'x', 'x', 'x') #: (x, x, x, x)
print A.B.C.foo('x', 'x', 'x', 'x') #: (x, x, x, x)
print A.B.C.foo('x', 'x', 'x', 'x') #: (x, x, x, x)

x = A.B.C[bool]()
print x.__class__ #: A.A.B.A.B.C[bool]

#%% nested_deep_class_error,barebones
class A[T]:
    a: T
    class B[U]:
        b: U
        class C[V]:
            c: V
            def foo[W](t: V, u: V, v: V, w: W):
                return (t, u, v, w)
print A.B.C[float].foo(1,1,1,True) #! ERROR: cannot unify int and float

#%% nested_deep_class_error_2,barebones
class A[T]:
    a: T
    class B[U]:
        b: U
        class C[V]:
            c: V
            def foo[W](t: V, u: V, v: V, w: W):
                return (t, u, v, w)
print A.B[int].C[float].foo(1,1,1,True) #! ERROR: cannot find 'C' in A.A.B[int]

#%% nested_class_function,barebones
def f(x):
    def g(y):
        return y
    a = g(1)
    b = g('s')
    c = g(x)
    return a, b, c
print f(1.1).__class__ #: Tuple.N3[int,str,float]
print f(False).__class__ #: Tuple.N3[int,str,bool]

class A[T]:
    a: T
    class B[U]:
        b: U
        class C[V]:
            c: V
            def f(x):
                def g(y):
                    return y
                a = g(1)
                b = g('s')
                c = g(x)
                return a, b, c
print A.B.C.f(1.1).__class__ #: Tuple.N3[int,str,float]
print A.B.C[Optional[int]].f(False).__class__ #: Tuple.N3[int,str,bool]

#%% rec_class_1,barebones
class A:
    y: A
    def __init__(self): pass  # necessary to prevent recursive instantiation!
x = A()
print x.__class__, x.y.__class__ #: A A

#%% rec_class_2,barebones
class A[T]:
    a: T
    b: A[T]
    c: A[str]
    def __init__(self): pass
a = A[int]()
print a.__class__, a.b.__class__, a.c.__class__, a.b.b.__class__, a.b.c.__class__
#: A[int] A[int] A[str] A[int] A[str]
print a.c.b.__class__, a.c.c.__class__, a.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.__class__
#: A[str] A[str] A[int]

#%% rec_class_3,barebones
class X:
    x: int
    rec: X
    def __init__(self): pass
    def foo(x: X, y: int):
        return y
    class Y:
        y: int
        def bar(self, y):
            print y
            return self.y
x, y = X(), X.Y()
print x.__class__, y.__class__
#: X X.X.Y
print X.foo(x, 4), x.foo(5)
#: 4 5
print y.bar(1), y.bar('s'), X.Y.bar(y, True)
#: 1
#: 0 s
#: 0 True
#: 0

#%% rec_class_4,barebones
class A[T]:
    a: T
    b: A[T]
    c: A[str]
    def __init__(self): pass
class B[T]:
    a: T
    b: A[T]
    c: B[T]
    def __init__(self): pass
    class Nest1[U]:
        n: U
    class Nest2[T, U]:
        m: T
        n: U
b = B[float]()
print b.__class__, b.a.__class__, b.b.__class__, b.c.__class__, b.c.b.c.a.__class__
#: B[float] float A[float] B[float] str

n1 = B.Nest1[int]()
print n1.n, n1.__class__, n1.n.__class__ #: 0 B.B.Nest1[int] int

n1: B.Nest2 = B.Nest2[float, int]()
print (n1.m, n1.n), n1.__class__, n1.m.__class__, n1.n.__class__ #: (0, 0) B.B.Nest2[float,int] float int

#%% func_arg_instantiate,barebones
class A[T]:
    y: T
    def foo(self, y: T):
        self.y = y
        return y
    def bar(self, y):
        return y
a = A()
print a.__class__ #: A[int]
a.y = 5
print a.__class__ #: A[int]

b = A()
print b.foo(5) #: 5
print b.__class__, b.y #: A[int] 5
print b.bar('s'), b.bar('s').__class__ #: s str
print b.bar(5), b.bar(5).__class__ #: 5 int

aa = A()
print aa.foo('s') #: s
print aa.__class__, aa.y, aa.bar(5.1).__class__ #: A[str] s float

#%% no_func_arg_instantiate_err,barebones
# TODO: allow unbound self?
class A[T]:
    y: T
    def foo(self, y): self.y = y
a = A()
a.foo(1) #! ERROR: cannot resolve 2 unbound variables

#%% return_deduction,barebones
def fun[T, R](x, y: T) -> R:
   	def ffi[T, Z](x: T, y: R, z: Z):
   		return (x, y, z)
   	yy = ffi[bool, str](False, byte(2), 's')
   	yz = ffi[int, str](1, byte(2), 's')
   	return byte(1)
print fun[float,byte](2, 1.1).__class__ #: byte

#%% return_auto_deduction_err,barebones
def fun[T, R](x, y: T) -> R:
   	return byte(1)
print fun(2, 1.1).__class__ #! ERROR: cannot resolve 1 unbound variables

#%% random
# shuffle used to fail before for some reason (sth about unbound variables)...
def foo():
    from random import shuffle
    v = list(range(10))
    shuffle(v)
    print sorted(v) #: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
foo()
