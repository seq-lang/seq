
"""
Represent a Sequence Feature holding info about a part of a sequence.
TODO/CAVEATS:
@jordan- For now MutableSeq is left out
"""
EXACT = 0
BEFORE = 1
AFTER = 2

class Position:
    """
    Specify the specific position of a boundary.
    """
    pos: int
    mode: int
    extension: int

    def __init__(cls: Position, position: int, mode: int, extension: int=0):
        if extension != 0:
            raise AttributeError(f"Non-zero extension {extension} for exact position.")

        if not 0 <= mode <= 2:
            raise ValueError(f"mode must be a value of EXACT={EXACT}, BEFORE={BEFORE}, AFTER={AFTER}.")

        cls.pos = position
        cls.mode = mode
    
    @property
    def position(self: Position):
        """
        Legacy attribute to get position as integer (OBSOLETE).
        """
        return self.pos
    
    @property
    def extension(self: Position):  # noqa: D402
        """
        Legacy attribute to get extension (zero) as integer (OBSOLETE).
        """
        return 0

    def __repr__(self: Position):
        """
        Represent the location as a string for debugging.
        """
        return f"{self.__class__.__name__}({self.pos})" 

    def __str__(self: Position):
        """
        Return a representation of the Position object.
        """
        if self.mode == EXACT:
            return f"{self.pos}"
        elif self.mode == BEFORE:
            return f"<{self.pos}"
        else:
            return f">{self.pos}"

    def _shift(self: Position, offset: int):
        """
        Return a copy of the position object with its location shifted (PRIVATE).
        """
        return self.__class__(self.pos + offset)

    def _flip(self: Position, length: int):
        """
        Return a copy of the location after the parent is reversed (PRIVATE).
        """
        if self.mode == EXACT:
            # By default perserve any subclass
            return self.__class__(length = self.pos)
        elif self.mode == BEFORE:
            return Position(length - self.pos, 2, 0)
        else:
            return Position(length - self.pos, 1, 0)

# class WithinPosition(int, AbstractPosition):
class WithinPosition:
    """
    Specify the position of a boundary within some coordinates.
    """
    pos: int
    left: int
    right: int

    def __init__(cls: WithinPosition, position: int, left: int, right: int):
        """
        Create a WithinPosition object.
        """
        if not (position == left or position == right):
            raise RuntimeError(f"WithinPosition: {position} should match left {left} or right {right}")
        cls.pos = position
        cls.left = left
        cls.right = right

    def __getnewargs__(self: WithinPosition):
        """
        Return the arguments accepted by __init__.
        Necessary to allow pickling and unpickling of class instances.
        """
        return (int(self), self._left, self._right)

    def __repr__(self: WithinPosition):
        """
        Represent the WithinPosition object as a string for debugging.
        """
        return f"{self.__class__.__name__}({int(self)}, left={self._left}, right={self._right})" \

    def __str__(self: WithinPosition):
        """
        Return a representation of the WithinPosition object.
        """
        return f"({self.left}.{self.right})" 

    @property
    def position(self: WithinPosition):
        """
        Legacy attribute to get (left) position as integer (OBSOLETE).
        """
        return self.pos

    @property
    def extension(self: WithinPosition):  # noqa: D402
        """
        Legacy attribute to get extension (from left to right) as an integer (OBSOLETE).
        """
        return self.right - self.left

    def _shift(self: WithinPosition, offset: int):
        """
        Return a copy of the position object with its location shifted (PRIVATE).
        """
        return self.__class__(int(self) + offset,
                              self.left + offset,
                              self.right + offset)

    def _flip(self: WithinPosition, length: int):
        """
        Return a copy of the location after the parent is reversed (PRIVATE).
        """
        return self.__class__(length - int(self),
                              length - self.right,
                              length - self.left)

extend int:
    def __init__(self: int, w: WithinPosition): 
        return w.pos

# --- Handling feature locations

#class FeatureLocation(object):
class FeatureLocation:
    """
    Specify the location of a feature along a sequence.
    """
    _start: int
    _end: int
    _strand: int
    _ref: str 
    _ref_db: str

    def __init__(self: FeatureLocation, start: int, end: int, strand: optional[int]=None, ref: optional[str]=None, ref_db: optional[str]=None):
        """
        Initialize the class.
        """

        self._start = start
        self._end = end

        if self._start > self._end:
            raise ValueError(f"End location {self._end} must be greater than or equal to start location {self._start}.")

        self._strand = strand
        self._ref = ref
        self._ref_db = ref_db
    
    def __init__(self: FeatureLocation, start: Position, end: Position, strand: int, ref: str, ref_db: str):
        """
        Initialize the class.
        """

        self._start = start.pos
        self._end = end.pos

        if self._start > self._end:
            raise ValueError(f"""End location ({self._end}) must be greater than or equal 
                             to start location ({self._start})""")
        self._strand = strand
        self._ref = ref
        self._ref_db = ref_db
    
    # def __init__(self: FeatureLocation, start: Position, end: WithinPosition, strand: int, ref: str, ref_db: str):
    #     """
    #     Initialize the class.
    #     """

    #     self._start = start.pos
    #     self._end = end.pos

    #     if self._start > self._end:
    #         raise ValueError(f"""End location ({self._end}) must be greater than or equal 
    #                          to start location ({self._start})""")
    #     self._strand = strand
    #     self._ref = ref
    #     self._ref_db = ref_db

    def _get_strand(self: FeatureLocation) -> int:
        """
        Get function for the strand property (PRIVATE).
        """
        return self._strand

    def _set_strand(self: FeatureLocation, value: int):
        """
        Set function for the strand property (PRIVATE).
        """
        if value not in [+1, -1, 0, None]:
            raise ValueError(f"Strand should be +1, -1, 0 or None, not {value}")
        self._strand = value

    @property
    def strand(self: FeatureLocation, fget: optional[int]=None, fset: optional[int]=None, doc: str="Strand of the location (+1, -1, 0 or None)."):
        if fget is None:
            fget = self._get_strand
        if fset is None:
            fset = self._set_strand
        return self._strand

    def __str__(self: FeatureLocation):
        """
        Return a representation of the FeatureLocation object.
        """
        answer = f"[{self._start}:{self._end}]"
        if self._ref and self._ref_db:
            answer = f"{self._ref_db}:{self._ref}{answer}"
        elif self._ref:
            answer = self._ref + answer
        if self._strand:
            return answer
        elif self._strand == +1:
            return answer + "(+)"
        elif self._strand == -1:
            return answer + "(-)"
        else:
            # strand = 0, stranded but strand unknown, ? in GFF3
            return answer + "(?)"

    def __repr__(self: FeatureLocation):
        """
        Represent the FeatureLocation object as a string for debugging.
        """
        optional = ""
        if self._strand is not None:
            optional += F", strand={self._strand}"
        if self.ref is not None:
            optional += f", ref={self._ref}" 
        if self.ref_db is not None:
            optional += f", ref_db={self._ref_db}" 
        return f"{self.__class__.__name__}({self._start}, {self._end}{optional})" \

    # Not sure about `other` type
    def __radd__(self: FeatureLocation, other: int):
        """
        Add a feature locationanother FeatureLocation object to the left.
        """
        return self._shift(other)


    def __nonzero__(self: FeatureLocation):
        """
        Return True regardless of the length of the feature.
        """
        return True

    def __len__(self: FeatureLocation):
        """
        Return the length of the region described by the FeatureLocation object.
        """
        return int(self._end) - int(self._start)

    def __contains__(self: FeatureLocation, value: int):
        """
        Check if an integer position is within the FeatureLocation object.
        """
        if value < self._start or value >= self._end:
            return False
        else:
            return True

    def __iter__(self: FeatureLocation):
        """
        Iterate over the parent positions within the FeatureLocation object.
        """
        if self.strand == -1:
            for i in range(self._end - 1, self._start - 1, -1):
                yield i
        else:
            for i in range(self._start, self._end):
                yield i

    def __eq__(self: FeatureLocation, other: FeatureLocation):
        """
        Implement equality by comparing all the location attributes.
        """
        return self._start == other._start and \
            self._end == other._end and \
            self._strand == other._strand and \
            self._ref == other._ref and \
            self._ref_db == other._ref_db

    def __ne__(self: FeatureLocation, other: FeatureLocation):
        """
        Implement the not-equal operand.
        """
        return not self == other

    def _shift(self: FeatureLocation, offset: int):
        """
        Return a copy of the FeatureLocation shifted by an offset (PRIVATE).
        """
        if self._ref or self._ref_db:
            raise ValueError("Feature references another sequence.")
        return FeatureLocation(start=self._start._shift(offset),
                               end=self._end._shift(offset),
                               strand=self._strand)

    def _flip(self: FeatureLocation, length):
        """
        Return a copy of the location after the parent is reversed (PRIVATE).
        """
        flip_strand = 0
        if self.ref or self._ref_db:
            raise ValueError("Feature references another sequence.")
        # Note this will flip the start and end too!
        if self._strand == +1:
            flip_strand = -1
        elif self._strand == -1:
            flip_strand = +1
        else:
            # 0 or None
            flip_strand = self._strand
        return FeatureLocation(start=self._end._flip(length),
                               end=self._start._flip(length),
                               strand=flip_strand)

    @property
    def parts(self: FeatureLocation):
        """
        Read only list of sections (always one, the FeatureLocation object).
        """
        return [self]

    @property
    def start(self: FeatureLocation):
        """
        Start location - left most (minimum) value, regardless of strand.
        """
        return self._start

    @property
    def end(self: FeatureLocation):
        """
        End location - right most (maximum) value, regardless of strand.
        """
        return self._end

    @property
    def nofuzzy_start(self: FeatureLocation):
        """
        Start position (integer, approximated if fuzzy, read only) (OBSOLETE).
        """
        return self._start

    @property
    def nofuzzy_end(self: FeatureLocation):
        """
        End position (integer, approximated if fuzzy, read only) (OBSOLETE).
        """
        return self._end

    # TODO/CAVEATS:
    # @jordan- reverse_complement needs to be implemented still
    # def extract(self: FeatureLocation, parent_sequence: seq):
    #     """
    #     Extract the sequence from supplied parent sequence using the FeatureLocation object.
    #     """
    #     if self.ref or self.ref_db:
    #         raise ValueError("Feature references another sequence.")
            
    #     f_seq = parent_sequence[self.nofuzzy_start:self.nofuzzy_end]
    #     if self.strand == -1:
    #         f_seq = reverse_complement(f_seq)
    
    #     return f_seq
    
    # def extract(self: FeatureLocation, parent_sequence: str):
    #     """
    #     Extract the sequence from supplied parent sequence using the FeatureLocation object.
    #     """
    #     if self.ref or self.ref_db:
    #         raise ValueError("Feature references another sequence.")
            
    #     f_seq = parent_sequence[self.nofuzzy_start:self.nofuzzy_end]
    #     if self.strand == -1:
    #         f_seq = reverse_complement(f_seq)
    
    #     return f_seq

# class SeqFeature(object):
class SeqFeature:
    """
    Represent a Sequence Feature on an object.
    """
    location: FeatureLocation
    typ: str
    location_operator: str
    strand: int
    id: str
    qualifiers: dict[str, list[str]]
    ref: str
    ref_db: str
    

    def __init__(self: SeqFeature, location: optional[FeatureLocation]=None, typ: str="", location_operator: str="",
                 strand: optional[int]=None, id: str="<unknown id>",
                 qualifiers: optional[dict[str, list[str]]]=None,
                 ref: optional[str]=None, ref_db: optional[str]=None):
        """
        Initialize a SeqFeature on a Sequence.
        location can either be a FeatureLocation (with strand argument also
        given if required), or None.

        TODO/CAVEATS:
        @jordan - took out sub_features from parameter for now
                - Because OrderedDict is not implemented yet, qualifiers is manditory 
        """

        self.location = location
        self.typ = typ

        if location_operator:
            self.location_operator = location_operator

        if strand is not None:
            self.strand = strand

        self.id = id
        self.qualifiers = qualifiers

        if ref:
            self.ref = ref

        if ref_db:
            self.ref_db = ref_db

    def _get_strand(self: SeqFeature):
        """
        Get function for the strand property (PRIVATE).
        """
        return self.location.strand

    def _set_strand(self: SeqFeature, value: int):
        """
        Set function for the strand property (PRIVATE).
        """
        self.location.strand = value

    @property
    def strand(self: SeqFeature, fget: optional[int]=None, fset: optional[int]= None, doc="""Feature's strand
                This is a shortcut for feature.location.strand"""):
        if fget is None:
            fget = self._get_strand
        if fset is None:
            fset = self._set_strand
        return self._strand


    def _get_ref(self: SeqFeature):
        """
        Get function for the reference property (PRIVATE).
        """
        return self.location.ref


    def _set_ref(self: SeqFeature, value):
        """
        Set function for the reference property (PRIVATE).
        """
        self.location.ref = value

    @property
    def ref(self: SeqFeature, fget: optional[int]=None, fset: optional[int]= None, 
            doc="""Feature location reference (e.g. accession).
            This is a shortcut for feature.location.ref
            """):
        if fget is None:
            fget = self._get_ref
        if fset is None:
            fset = self._set_ref

        return self._ref

    def _get_ref_db(self: SeqFeature):
        """
        Get function for the database reference property (PRIVATE).
        """
        return self.location.ref_db


    def _set_ref_db(self: SeqFeature, value):
        """
        Set function for the database reference property (PRIVATE).
        """
        self.location.ref_db = value
    
    @property
    def ref_db(self: SeqFeature, fget: optional[int]= None, fset: optional[int]=None,
                doc="""Feature location reference's database.
                This is a shortcut for feature.location.ref_db
                """):
        if fget is None:
            fget = self._get_ref_db
        if fset is None:
            fset = self._set_ref_db
        return self._ref_db

    def _get_location_operator(self: SeqFeature):
        """
        Get function for the location operator property (PRIVATE).
        """
        return self.location.operator

    def _set_location_operator(self, value):
        """
        Set function for the location operator property (PRIVATE).
        """
        self.location.operator = value

    @property
    def location_operator(self: SeqFeature, fget: optional[str]=None, fset: optional[str]=None,
                        doc="Location operator for compound locations (e.g. join)."):
        if fget is None:
            fget = self._get_location_operator
        if fset is None:
            fset = self._set_location_operator
        return self._location_operator

    def __repr__(self: SeqFeature):
        """
        Represent the feature as a string for debugging.
        """
        answer = f"{self.__class__.__name__}({self.repr(self.location)}"
        if self.typ:
            answer += f", type={self.repr(self.typ)}" 
        if self.location_operator:
            answer += f", location_operator={self.repr(self.location_operator)}" 
        if self.id and self.id != "<unknown id>":
            answer += f", id={self.repr(self.id)}" 
        if self.ref:
            answer += f", ref={self.repr(self.ref)}" 
        if self.ref_db:
            answer += f", ref_db={self.repr(self.ref_db)}"
        answer += ")"
        return answer

    def __str__(self: SeqFeature):
        """
        Return the full feature as a python string.
        """
        out = f"type: {self.typ}\n" 
        out += f"location: {self.location}\n"
        if self.id and self.id != "<unknown id>":
            out += f"id: {self.id}\n"
        out += "qualifiers:\n"
        for qual_key in sorted(self.qualifiers):
            out += f"    Key: {qual_key}, Value: {self.qualifiers[qual_key]}\n" 
        return out

    def _shift(self: SeqFeature, offset):
        """
        Return a copy of the feature with its location shifted (PRIVATE).
        The annotation qaulifiers are copied.
        """
        return SeqFeature(location=self.location._shift(offset),
                          typ=self.typ,
                          location_operator=self.location_operator,
                          id=self.id,
                          qualifiers=self.OrderedDict(self.qualifiers.items()))

    def _flip(self: SeqFeature, length: int):
        """
        Return a copy of the feature with its location flipped (PRIVATE).
        """
        return SeqFeature(location=self.location._flip(length),
                          typ=self.typ,
                          location_operator=self.location_operator,
                          id=self.id,
                          qualifiers=self.OrderedDict(self.qualifiers.items()))

    def extract(self: SeqFeature, parent_sequence: seq):
        """
        Extract the feature's sequence from supplied parent sequence.
        """
        if self.location is None:
            raise ValueError("The feature's .location is None. Check the "
                             "sequence file for a valid location.")
        return self.location.extract(parent_sequence)
    
    def extract(self: SeqFeature, parent_sequence: str):
        """
        Extract the feature's sequence from supplied parent sequence.
        """
        if self.location is None:
            raise ValueError("The feature's .location is None. Check the "
                             "sequence file for a valid location.")
        return self.location.extract(parent_sequence)

    def translate(self: SeqFeature, parent_sequence, table="Standard", start_offset: optional[int]=None,
                  stop_symbol="*", to_stop=False, cds=None, gap=None):
        """
        Get a translation of the feature's sequence.
        """
        # see if this feature should be translated in a different
        # frame using the "codon_start" qualifier
        if start_offset is None:
            try:
                start_offset = int(self.qualifiers["codon_start"][0]) - 1

            except KeyError:
                start_offset = 0

        if start_offset not in [0, 1, 2]:
            raise ValueError(f"""The start_offset must be 0, 1, or 2. 
                             The supplied value is {start_offset}. Check the value 
                             of either the codon_start qualifier or 
                             the start_offset argument""")

        feat_seq = self.extract(parent_sequence)[start_offset:]
        codon_table = self.qualifiers.get("transl_table", [table])[0]

        if cds is None:
            cds = (self.typ == "CDS")

        return feat_seq.translate(table=codon_table, stop_symbol=stop_symbol,
                                  to_stop=to_stop, cds=cds, gap=gap)

    def __bool__(self):
        """
        Boolean value of an instance of this class (True).
        """
        return True

    def __len__(self):
        """
        Return the length of the region where the feature is located.
        """
        return len(self.location)

    def __iter__(self):
        """
        Iterate over the parent positions within the feature.
        """
        return iter(self.location)

    def __contains__(self, value):
        """
        Check if an integer position is within the feature.
        """
        return value in self.location


# --- References

#class Reference(object):
class Reference:
    """
    Represent a Generic Reference object.
    """
    location: list[FeatureLocation]
    authors: str
    title: str
    journal: str
    medline_id: str
    pubmed_id: str
    comment: str

    def __init__(self: Reference):
        """
        Initialize the class.
        """
        self.location = list[FeatureLocation]()
        self.authors = ""
        self.consrtm = ""
        self.title = ""
        self.journal = ""
        self.medline_id = ""
        self.pubmed_id = ""
        self.comment = ""

    def __str__(self: Reference):
        """
        Return the full Reference object as a python string.
        """
        out = ""
        for single_location in self.location:
            out += f"location: {single_location}\n"
        out += f"authors: {self.authors}\n" 
        if self.consrtm:
            out += f"consrtm: {self.consrtm}\n"
        out += f"title: {self.title}\n"
        out += f"journal: {self.journal}\n"
        out += f"medline id: {self.medline_id}\n"
        out += f"pubmed id: {self.pubmed_id}\n"
        out += f"comment: {self.comment}\n"
        return out

    def __repr__(self: Reference):
        """
        Represent the Reference object as a string for debugging.
        """
        return f"{self.__class__.__name__}(title={self.repr(self.title)}, ...)" 

    def __eq__(self: Reference, other: Reference):
        """
        Check if two Reference objects should be considered equal.
        """
        return self.authors == other.authors and \
            self.consrtm == other.consrtm and \
            self.title == other.title and \
            self.journal == other.journal and \
            self.medline_id == other.medline_id and \
            self.pubmed_id == other.pubmed_id and \
            self.comment == other.comment and \
            self.location == other.location

    def __ne__(self: Reference, other: Reference):
        """
        Implement the not-equal operand.
        """
        return not self == other

#class CompoundLocation(object):
class CompoundLocation:
    """
    For handling joins etc where a feature location has several parts.
    """
    parts: list[FeatureLocation]
    operator: str

    def __init__(self: CompoundLocation, parts: list[FeatureLocation], operator: str="join"):
        """
        Initialize the class.
        """
        self.operator = operator
        self.parts = parts

        if len(parts) < 2:
            raise ValueError(f"CompoundLocation should have at least 2 parts, not {parts}") 

    def __str__(self: CompoundLocation):
        """
        Return a representation of the CompoundLocation object.
        """
        return f"""{self.operator}{{(", ".join(list(str(loc) for loc in self.parts)))}} """

    def __repr__(self: CompoundLocation):
        """
        Represent the CompoundLocation object as string for debugging.
        """
        return f"{self.__class__.__name__}({self.parts}, {self.operator})"
                                

    def _get_strand(self: CompoundLocation):
        """
        Get function for the strand property (PRIVATE).
        """
        if len({loc.strand for loc in self.parts}) == 1:
            return self.parts[0].strand
        else:
            return None  # i.e. mixed strands

    def _set_strand(self: CompoundLocation, value: int):
        """
        Set function for the strand property (PRIVATE).
        """
        for loc in self.parts:
            loc.strand = value
    
    @property
    def strand(self: CompoundLocation, fget: optional[int]=None, fset: optional[int]=None,
                doc="""Overall strand of the compound location.
                If all the parts have the same strand, that is returned. Otherwise
                for mixed strands, this returns None.
                >>> from Bio.SeqFeature import FeatureLocation, CompoundLocation
                >>> f1 = FeatureLocation(15, 17, strand=1)
                >>> f2 = FeatureLocation(20, 30, strand=-1)
                >>> f = f1 + f2
                >>> f1.strand
                1
                >>> f2.strand
                -1
                >>> f.strand
                >>> f.strand is None
                True
                If you set the strand of a CompoundLocation, this is applied to
                all the parts - use with caution:
                >>> f.strand = 1
                >>> f1.strand
                1
                >>> f2.strand
                1
                >>> f.strand
                1
                """):
        if fget is None:
            fget = self._get_strand
        if fset is None:
            fset = self._set_strand
        return self._strand

    def __add__(self: CompoundLocation, other: FeatureLocation):
        """
        Combine locations.
        """
        return CompoundLocation(self.parts + [other], self.operator)

    def __add__(self: CompoundLocation, other: CompoundLocation):
        """
        Combine locations.
        """ 
        if self.operator != other.operator:
            # Handle join+order -> order as a special case?
            raise ValueError(F"Mixed operators {self.operator} and {other.operator}")
        return CompoundLocation(self.parts + other.parts, self.operator)
    
    def __add__(self: CompoundLocation, other: int):
        """
        Shift the location by an integer offset.
        """
        return self._shift(other)
 

    def __radd__(self: CompoundLocation, other: FeatureLocation):
        """
        Add a feature to the left.
        """
        return CompoundLocation([other] + self.parts, self.operator)
    

    def __radd__(self: CompoundLocation, other: int):
        """
        Add a feature to the left.
        """
        return self._shift(other)


    def __contains__(self: CompoundLocation, value: int):
        """
        Check if an integer position is within the CompoundLocation object.
        """
        for loc in self.parts:
            if value in loc:
                return True
        return False

    def __nonzero__(self: CompoundLocation):
        """
        Return True regardless of the length of the feature.
        """
        return True

    def __len__(self: CompoundLocation):
        """
        Return the length of the CompoundLocation object.
        """
        return sum(len(loc) for loc in self.parts)

    def __iter__(self: CompoundLocation):
        """
        Iterate over the parent positions within the CompoundLocation object.
        """
        for loc in self.parts:
            for pos in loc:
                yield pos

    def __eq__(self: CompoundLocation, other: CompoundLocation):
        """
        Check if all parts of CompoundLocation are equal to all parts of other CompoundLocation.
        """
        if len(self.parts) != len(other.parts):
            return False
        if self.operator != other.operator:
            return False
        for self_part, other_part in zip(self.parts, other.parts):
            if self_part != other_part:
                return False
        return True

    def __ne__(self: CompoundLocation, other: CompoundLocation):
        """
        Implement the not-equal operand.
        """
        return not self == other

    def _shift(self: CompoundLocation, offset: int):
        """
        Return a copy of the CompoundLocation shifted by an offset (PRIVATE).
        """
        return CompoundLocation([loc._shift(offset) for loc in self.parts],
                                self.operator)

    def _flip(self: CompoundLocation, length: int):
        """
        Return a copy of the locations after the parent is reversed (PRIVATE).
        """
        return CompoundLocation([loc._flip(length) for loc in self.parts],
                                self.operator)

    @property
    def start(self: CompoundLocation):
        """
        Start location - left most (minimum) value, regardless of strand.
        """
        return min(loc.start for loc in self.parts)

    @property
    def end(self: CompoundLocation):
        """
        End location - right most (maximum) value, regardless of strand.
        """
        return max(loc.end for loc in self.parts)

    @property
    def nofuzzy_start(self: CompoundLocation) -> int:
        """
        Start position (integer, approximated if fuzzy, read only) (OBSOLETE).
        """
        return int(self.start)

    @property
    def nofuzzy_end(self: CompoundLocation) -> int:
        """
        End position (integer, approximated if fuzzy, read only) (OBSOLETE).
        """
        return int(self.end)


    @property
    def ref(self: CompoundLocation):
        """
        Not present in CompoundLocation, dummy method for API compatibility.
        """
        return None

    @property
    def ref_db(self: CompoundLocation):
        """
        Not present in CompoundLocation, dummy method for API compatibility.
        """
        return None

    def extract(self: CompoundLocation, parent_sequence: seq):
        """
        Extract the sequence from supplied parent sequence using the CompoundLocation object.
        """
        # This copes with mixed strand features & all on reverse:
        parts = [loc.extract(parent_sequence) for loc in self.parts]
        # We use addition rather than a join to avoid alphabet issues:
        f_seq = parts[0]
        for part in parts[1:]:
            f_seq += part
        return f_seq
    
    def extract(self: CompoundLocation, parent_sequence: str):
        """
        Extract the sequence from supplied parent sequence using the CompoundLocation object.
        """
        # This copes with mixed strand features & all on reverse:
        parts = [loc.extract(parent_sequence) for loc in self.parts]
        # We use addition rather than a join to avoid alphabet issues:
        f_seq = parts[0]
        for part in parts[1:]:
            f_seq += part
        return f_seq

extend FeatureLocation:
    def __add__(self: FeatureLocation, other: FeatureLocation):
        """
        Combine location with another FeatureLocation object, or shift it.
        """
        return CompoundLocation([self, other], "join")

# class AbstractPosition(object):
class AbstractPosition:
    """
    Abstract base class representing a position.
    """

    def __repr__(self: AbstractPosition):
        """
        Represent the AbstractPosition object as a string for debugging.
        """
        return f"{self.__class__.__name__}(...)"

# class UnknownPosition(AbstractPosition):
class UnknownPosition:
    """
    Specify a specific position which is unknown (has no position).
    """

    def __repr__(self: UnknownPosition):
        """
        Represent the UnknownPosition object as a string for debugging.
        """
        return f"{self.__class__.__name__}()" 

    # TODO/CAVEATS:
    # @jordan - hash values
    # def __hash__(self: UnknownPosition):
    #     """
    #     Return the hash value of the UnknownPosition object.
    #     """
    #     return hash(None)

    @property
    def position(self: UnknownPosition):
        """
        Legacy attribute to get location (None) (OBSOLETE).
        """
        return None

    @property
    def extension(self: UnknownPosition):  # noqa: D402
        """
        Legacy attribute to get extension (zero) as integer (OBSOLETE).
        """
        return 0

    def _shift(self: UnknownPosition, offset: int):
        """
        Return a copy of the position object with its location shifted (PRIVATE).
        """
        return self

    def _flip(self: UnknownPosition, length: int):
        """
        Return a copy of the location after the parent is reversed (PRIVATE).
        """
        return self

# class BetweenPosition(int, AbstractPosition):
class BetweenPosition:
    """
    Specify the position of a boundary between two coordinates (OBSOLETE?).
    """
    pos: int
    left: int
    right: int

    def __init__(cls: BetweenPosition, position: int, left: int, right: int):
        """
        Create a new instance in BetweenPosition object.
        """
        assert position == left or position == right 
        cls.pos = position
        cls.left = left
        cls.right = right


    def __getnewargs__(self: BetweenPosition):
        """
        Return the arguments accepted by __init__.
        Necessary to allow pickling and unpickling of class instances.
        """
        return (int(self), self._left, self._right)

    def __repr__(self: BetweenPosition):
        """
        Represent the BetweenPosition object as a string for debugging.
        """
        return f"{self.__class__.__name__}({int(self)}, left={self._left}, right={self._right})" \

    def __str__(self: BetweenPosition):
        """
        Return a representation of the BetweenPosition object (with python counting).
        """
        return f"({self.left}^{self.right})"

    @property
    def position(self: BetweenPosition):
        """
        Legacy attribute to get (left) position as integer (OBSOLETE).
        """
        return self.left

    @property
    def extension(self: BetweenPosition):  # noqa: D402
        """
        Legacy attribute to get extension (from left to right) as an integer (OBSOLETE).
        """
        return self._right - self._left

    def _shift(self: BetweenPosition, offset: int):
        """
        Return a copy of the position object with its location shifted (PRIVATE).
        """
        return self.__class__(int(self) + offset,
                              self._left + offset,
                              self._right + offset)

    def _flip(self: BetweenPosition, length: int):
        """
        Return a copy of the location after the parent is reversed (PRIVATE).
        """
        return self.__class__(length - int(self),
                              length - self._right,
                              length - self._left)
extend int:
    def __init__(self: int, b: BetweenPosition): 
        return b.pos

# TODO/CAVEATS
# @jordan- OneofPosition has not been tested yet.
# #class OneOfPosition(int, AbstractPosition)
# class OneOfPosition:
#     """
#     Specify a position where the location can be multiple positions.
#     """
#     position_choices: int
#     choices: list[Position]

#     def __init__(cls: OneOfPosition, position: int, choices: list[Position]):
#         """
#         Initialize with a set of possible positions.
#         position_list is a list of AbstractPosition derived objects,
#         specifying possible locations.
#         position is an integer specifying the default behaviour.
#         """
#         cls.position_choices = position
#         cls.choices = choices

#     def __getnewargs__(self: OneOfPosition) -> tuple[OneOfPosition, list[Position]]:
#         """
#         Return the arguments accepted by __init__.
#         Necessary to allow pickling and unpickling of class instances.
#         """
#         return (self, self.position_choices)

#     @property
#     def position(self: OneOfPosition):
#         """
#         Legacy attribute to get (left) position as integer (OBSOLETE).
#         """
#         return min(int(pos) for pos in self.position_choices)

#     @property
#     def extension(self: OneOfPosition):
#         """
#         Legacy attribute to get extension as integer (OBSOLETE).
#         """
#         positions = [int(pos) for pos in self.position_choices]
#         return max(positions) - min(positions)

#     def __repr__(self: OneOfPosition):
#         """
#         Represent the OneOfPosition object as a string for debugging.
#         """
#         return f"{self.__class__.__name__}({int(self)}, choices={self.position_choices})" 
                                       

#     def __str__(self: OneOfPosition):
#         """
#         Return a representation of the OneOfPosition object.
#         """
#         out = "one-of("
#         for position in self.position_choices:
#             out += f"{position},"
#         # replace the last comma with the closing parenthesis
#         return out[:-1] + ")"

#     def _shift(self: OneOfPosition, offset: int):
#         """
#         Return a copy of the position object with its location shifted (PRIVATE).
#         """
#         return self.__class__(int(self) + offset,
#                               [p._shift(offset) for p in self.position_choices])

#     def _flip(self: OneOfPosition, length: int):
#         """
#         Return a copy of the location after the parent is reversed (PRIVATE).
#         """
#         return self.__class__(length - int(self),
#                               [p._flip(length) for p in self.position_choices[::-1]])

#class PositionGap(object):
class PositionGap:
    """
    Simple class to hold information about a gap between positions.
    """
    gap_size: int

    def __init__(self: PositionGap, gap_size: int):
        """
        Intialize with a position object containing the gap information.
        """
        self.gap_size = gap_size

    def __repr__(self: PositionGap):
        """
        Represent the position gap as a string for debugging.
        """
        return f"{self.__class__.__name__}({self.repr(self.gap_size)})" 

    def __str__(self: PositionGap):
        """
        Return a representation of the PositionGap object.
        """
        return f"gap({self.gap_size})"
