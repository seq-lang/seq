# FM-index implementation adapted from BWA-MEM's
# https://github.com/lh3/bwa

from random import randint

# obeys A < C < G < T
def _enc(b: byte):
    ENC_CANONINCAL = ('\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04'
                      '\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04'
                      '\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x05\x04\x04'
                      '\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04'
                      '\x04\x00\x04\x01\x04\x04\x04\x02\x04\x04\x04\x04\x04\x04\x04\x04'
                      '\x04\x04\x04\x04\x03\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04'
                      '\x04\x00\x04\x01\x04\x04\x04\x02\x04\x04\x04\x04\x04\x04\x04\x04'
                      '\x04\x04\x04\x04\x03\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04'
                      '\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04'
                      '\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04'
                      '\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04'
                      '\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04'
                      '\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04'
                      '\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04'
                      '\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04'
                      '\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04\x04')
    return int(ENC_CANONINCAL.ptr[int(b)])

class bntann:
    _offset: int
    _len: int
    _n_ambs: int
    _is_alt: bool
    _name: str
    _anno: str

    def __init__(self: bntann, name: str, anno: str, offset: int, len: int):
        self._offset = offset
        self._len = len
        self._n_ambs = 0
        self._is_alt = False
        self._name = name
        self._anno = anno

class bntamb:
    _offset: int
    _len: int
    _amb: byte

    def __init__(self: bntamb, offset: int, amb: byte):
        self._offset = offset
        self._len = 1
        self._amb = amb

def _pickle_ptr[T](p: ptr[T], n: int, jar: Jar):
    pickle(n, jar)
    for i in range(n):
        pickle(p[i], jar)

def _unpickle_ptr[T](jar: Jar):
    n = unpickle[int](jar)
    p = ptr[T](n)
    for i in range(n):
        p[i] = unpickle[T](jar)
    return (p, n)

class bntseq:
    _pac: ptr[u8]
    _m_pac: int
    _l_pac: int
    _n_seqs: int
    _anns: list[bntann]
    _ambs: list[bntamb]

    def __pickle__(self: bntseq, jar: Jar):
        pac_size = (self._l_pac // 4) + (0 if self._l_pac % 4 == 0 else 1)
        _pickle_ptr(self._pac, pac_size, jar)
        pickle((self._l_pac, self._n_seqs, self._anns, self._ambs), jar)

    def __unpickle__(jar: Jar):
        b = bntseq()
        pac, _ = _unpickle_ptr[u8](jar)
        l_pac, n_seqs, anns, ambs = unpickle[tuple[int, int, list[bntann], list[bntamb]]](jar)
        b._pac = pac
        b._m_pac = l_pac
        b._l_pac = l_pac
        b._n_seqs = n_seqs
        b._anns = anns
        b._ambs = ambs
        return b

    def __init__(self: bntseq):
        self._pac = ptr[u8]()
        self._m_pac = 0
        self._l_pac = 0
        self._n_seqs = 0
        self._anns = None
        self._ambs = None

    def __init__(self: bntseq, path: str):
        m_pac = 0x10000
        self._pac = ptr[u8](m_pac // 4)
        str.memset(ptr[byte](self._pac), byte(0), m_pac // 4)
        self._m_pac = m_pac
        self._l_pac = 0
        self._n_seqs = 0
        self._anns = list[bntann]()
        self._ambs = list[bntamb]()
        self._add_fasta(path)

    @property
    def _n_holes(self: bntseq):
        return len(self._ambs)

    def get_pac(pac: ptr[u8], l: int):
        return (pac[l >> 2] >> u8((~l & 3) << 1)) & u8(3)

    def _get_pac(self: bntseq, l: int):
        return bntseq.get_pac(self._pac, l)

    def _set_pac(self: bntseq, l: int, c: u8):
        assert (l >> 2) < (self._m_pac // 4)
        self._pac[l >> 2] |= c << u8((~l & 3) << 1)

    def _resize_pac_if_full(self: bntseq):
        l_pac = self._l_pac
        m_pac = self._m_pac
        if l_pac == m_pac:
            m_pac <<= 1
            self._pac = ptr[u8](_gc.realloc(ptr[byte](self._pac), m_pac // 4))
            str.memset(ptr[byte](self._pac + l_pac//4), byte(0), (m_pac - l_pac) // 4)
            self._m_pac = m_pac

    def _push_pac(self: bntseq, c: u8):
        self._resize_pac_if_full()
        self._set_pac(self._l_pac, c)
        self._l_pac += 1

    def _add1(self: bntseq, name: str, s: seq, anno: str):
        n = len(s)
        p = bntann(name, anno, 0 if self._n_seqs == 0 else self._anns[-1]._offset + self._anns[-1]._len, n)
        self._anns.append(p)
        q: bntamb = None

        lasts = byte(0)
        i = 0
        while i < n:
            b = s._at(i)
            c = u8(_enc(b))
            if c >= u8(4):
                if lasts == b:
                    q._len += 1
                else:
                    q = bntamb(p._offset + i, b)
                    p._n_ambs += 1
                    self._ambs.append(q)
                c = u8(randint(0, 3))
            lasts = b
            self._push_pac(c)
            i += 1
        self._n_seqs += 1

    def _add_fasta(self: bntseq, path: str):
        for rec in FASTA(path):
            self._add1(rec.name, rec.seq, rec.comment)

    def depos(self: bntseq, pos: int):
        l_pac = self._l_pac
        is_rev = (pos >= l_pac)
        if is_rev:
            pos = (l_pac << 1) - 1 - pos
        return (pos, is_rev)

    def pos2rid(self: bntseq, pos: int):
        if pos >= self._l_pac:
            return -1
        left = 0
        mid = 0
        right = self._n_seqs
        while left < right:
            mid = (left + right) >> 1
            if pos >= self._anns[mid]._offset:
                if mid == self._n_seqs - 1:
                    break
                if pos < self._anns[mid + 1]._offset:
                    break
                left = mid + 1
            else:
                right = mid
        return mid

    def intv2rid(self: bntseq, rb: int, re: int):
        if rb < self._l_pac and re > self._l_pac:
            return -2
        assert rb <= re
        rid_b = self._pos2rid(self._depos(rb)[0])
        rid_e = self._pos2rid(self._depos(re - 1)[0]) if rb < re else rid_b
        return rid_b if rid_b == rid_e else -1

    def cnt_ambi(self: bntseq, pos: int, len: int):
        left = 0
        right = self._n_holes
        nn = 0
        while left < right:
            mid = (left + right) >> 1
            if pos >= self._ambs[mid]._offset + self._ambs[mid]._len:
                left = mid + 1
            elif pos + len <= self._ambs[mid]._offset:
                right = mid
            else:
                if pos >= self._ambs[mid]._offset:
                    nn += (self._ambs[mid]._offset + self._ambs[mid]._len - pos) if (self._ambs[mid]._offset + self._ambs[mid]._len < pos + len) else len
                else:
                    nn += (self._ambs[mid]._len) if (self._ambs[mid]._offset + self._ambs[mid]._len < pos + len) else (len - (self._ambs[mid]._offset - len))
                break
        return nn

    def __len__(self: bntseq):
        return self._l_pac

    def __bool__(self: bntseq):
        return len(self) != 0

    def _get_seq(self: bntseq, beg: int, end: int):
        BASES = 'ACGT'
        pac = self._pac
        l_pac = self._l_pac
        if end < beg:
            beg, end = end, beg
        if end > l_pac << 1:
            end = l_pac << 1
        if beg < 0:
            beg = 0
        if beg >= l_pac or end <= l_pac:
            l = 0
            n = end - beg
            p = ptr[byte](n)
            if beg > l_pac:  # reverse strand
                beg_f = (l_pac << 1) - 1 - end
                end_f = (l_pac << 1) - 1 - beg
                k = end_f
                while k > beg_f:
                    p[l] = BASES.ptr[int(u8(3) - self._get_pac(k))]
                    l += 1
                    k -= 1
            else:  # forward strang
                k = beg
                while k < end:
                    p[l] = BASES.ptr[int(self._get_pac(k))]
                    l += 1
                    k += 1
            assert n >= 0
            return seq(p, n)
        else:
            return seq()

    def _fetch_seq(self: bntseq, beg: int, mid: int, end: int):
        if end < beg:
            beg, end = end, beg
        assert beg <= mid < end
        pos, is_rev = self.depos(mid)
        rid = self.pos2rid(pos)
        ann = self._anns[rid]
        far_beg = ann._offset
        far_end = far_beg + ann._len
        if is_rev:
            tmp = far_beg
            far_beg = (self._l_pac << 1) - far_end
            far_end = (self._l_pac << 1) - tmp
        beg = beg if beg > far_beg else far_beg
        end = end if end < far_end else far_end
        s = self._get_seq(beg, end)
        return s, rid, beg, end

    def get_seq(self: bntseq, lo: int, hi: int):
        if not (0 <= lo < hi <= len(self)):
            return seq()
        n = hi - lo
        p = ptr[byte](n)
        i = lo
        while i < hi:
            p[i - lo] = 'ACGT'.ptr[int(self._get_pac(i))]
            i += 1
        return seq(p, n)

type FMInterval(_lo: int, _hi: int):
    def __bool__(self: FMInterval):
        return self._lo <= self._hi

    def __len__(self: FMInterval):
        return self._hi - self._lo + 1 if self else 0

    def invalid():
        return FMInterval(-2, -1)

type FMDInterval(_lo: int, _lo_rev: int, _size: int, _info: int):
    def __bool__(self: FMDInterval):
        return self._size > 0

    def __len__(self: FMDInterval):
        return self._size

    def forward(self: FMDInterval):
        return FMInterval(self._lo, self._lo + self._size - 1)

    def revcomp(self: FMDInterval):
        return FMInterval(self._lo_rev, self._lo_rev + self._size - 1)

    def __invert__(self: FMDInterval):
        return FMDInterval(self._lo_rev, self._lo, self._size, self._info)

    def _with_info(self: FMDInterval, info: int):
        return FMDInterval(self._lo, self._lo_rev, self._size, info)

    @property
    def match_size(self: FMDInterval):
        return (self._info & 0xffffffff) - self.offset

    @property
    def offset(self: FMDInterval):
        return int(u64(self._info) >> u64(32))

    def invalid():
        return FMDInterval(0, 0, 0, 0)

def _extend(self, ik: FMDInterval, is_back: bool, info: tuple[int,int,int,int]):
    # adapted from BWA-MEM's bwt_extend()
    if is_back:
        tk, tl = self._2occ4(ik._lo - 1, ik._lo - 1 + ik._size)

        ok0_x0 = int(self._L2[0]) + 1 + tk[0]
        ok0_x2 = tl[0] - tk[0]
        ok1_x0 = int(self._L2[1]) + 1 + tk[1]
        ok1_x2 = tl[1] - tk[1]
        ok2_x0 = int(self._L2[2]) + 1 + tk[2]
        ok2_x2 = tl[2] - tk[2]
        ok3_x0 = int(self._L2[3]) + 1 + tk[3]
        ok3_x2 = tl[3] - tk[3]

        ok3_x1 = ik._lo_rev + (1 if (ik._lo <= self._primary and ik._lo + ik._size - 1 >= self._primary) else 0)
        ok2_x1 = ok3_x1 + ok3_x2
        ok1_x1 = ok2_x1 + ok2_x2
        ok0_x1 = ok1_x1 + ok1_x2
        return (FMDInterval(ok0_x0, ok0_x1, ok0_x2, info[0]), FMDInterval(ok1_x0, ok1_x1, ok1_x2, info[1]),
                FMDInterval(ok2_x0, ok2_x1, ok2_x2, info[2]), FMDInterval(ok3_x0, ok3_x1, ok3_x2, info[3]))
    else:
        tk, tl = self._2occ4(ik._lo_rev - 1, ik._lo_rev - 1 + ik._size)

        ok0_x1 = int(self._L2[0]) + 1 + tk[0]
        ok0_x2 = tl[0] - tk[0]
        ok1_x1 = int(self._L2[1]) + 1 + tk[1]
        ok1_x2 = tl[1] - tk[1]
        ok2_x1 = int(self._L2[2]) + 1 + tk[2]
        ok2_x2 = tl[2] - tk[2]
        ok3_x1 = int(self._L2[3]) + 1 + tk[3]
        ok3_x2 = tl[3] - tk[3]

        ok3_x0 = ik._lo + (1 if (ik._lo_rev <= self._primary and ik._lo_rev + ik._size - 1 >= self._primary) else 0)
        ok2_x0 = ok3_x0 + ok3_x2
        ok1_x0 = ok2_x0 + ok2_x2
        ok0_x0 = ok1_x0 + ok1_x2
        return (FMDInterval(ok0_x0, ok0_x1, ok0_x2, info[0]), FMDInterval(ok1_x0, ok1_x1, ok1_x2, info[1]),
                FMDInterval(ok2_x0, ok2_x1, ok2_x2, info[2]), FMDInterval(ok3_x0, ok3_x1, ok3_x2, info[3]))

def smems(self,
          q: seq,
          x: int = 0,
          min_intv: int = 1,
          max_intv: int = 0,
          mem: list[FMDInterval] = None,
          prev: list[FMDInterval] = None,
          curr: list[FMDInterval] = None):
    # adapted from BWA-MEM's bwt_smem1a()
    def infos(ok: tuple[FMDInterval,FMDInterval,FMDInterval,FMDInterval]):
        return (ok[0]._info, ok[1]._info, ok[2]._info, ok[3]._info)

    l = len(q)
    if x < 0:
        x += l
    if not (0 <= x < l):
        raise ValueError("sequence index out of range")

    if mem is None:
        mem = list[FMDInterval]()
    else:
        mem.clear()
    if q[x].N():
        return x + 1, mem

    if prev is None:
        prev = list[FMDInterval]()
    else:
        prev.clear()

    if curr is None:
        curr = list[FMDInterval]()
    else:
        curr.clear()

    if min_intv < 1:
        min_intv = 1

    ok = (FMDInterval(0, 0, 0, 0), FMDInterval(0, 0, 0, 0), FMDInterval(0, 0, 0, 0), FMDInterval(0, 0, 0, 0))
    ik = self.biinterval(q[x])._with_info(x + 1)

    # forward search
    i = x + 1
    while i < l:
        qi = _enc(q._at(i))
        if ik._size < max_intv:  # an interval small enough
            curr.append(ik)
            break
        elif qi < 4:  # an A/C/G/T base
            c = 3 - qi
            ok = _extend(self, ik, is_back=False, info=infos(ok))
            if ok[c]._size != ik._size:  # change of the interval size
                curr.append(ik)
                if ok[c]._size < min_intv:
                    break  # the interval size is too small to be extended further
            ik = ok[c]._with_info(i + 1)
        else:  # an ambiguous base
            curr.append(ik)
            break
        i += 1

    if i == l:
        curr.append(ik)
    curr.reverse()
    ret = curr[0]._info
    prev, curr = curr, prev

    # backward search for MEMs
    i = x - 1
    while i >= -1:
        qi = -1 if i < 0 else _enc(q._at(i))
        c = qi if qi < 4 else -1
        curr.clear()
        j = 0
        while j < len(prev):
            p = prev[j]
            if c >= 0 and ik._size >= max_intv:
                ok = _extend(self, p, is_back=True, info=infos(ok))
            if c < 0 or ik._size < max_intv or ok[c]._size < min_intv:
                if len(curr) == 0:
                    if len(mem) == 0 or i + 1 < mem[-1]._info >> 32:
                        ik = p._with_info(p._info | ((i + 1) << 32))
                        mem.append(ik)
            elif len(curr) == 0 or ok[c]._size != curr[-1]._size:
                okp = ptr[FMDInterval](__ptr__(ok))
                okp[c] = ok[c]._with_info(p._info)
                curr.append(ok[c])
            j += 1
        if len(curr) == 0:
            break
        prev, curr = curr, prev
        i -= 1

    mem.reverse()  # s.t. sorted by the start coordinate
    return ret, mem

OCC_INTV_SHIFT = 7
OCC_INTERVAL   =  1 << OCC_INTV_SHIFT
OCC_INTV_MASK  = OCC_INTERVAL - 1

class FMDIndex:
    _seq_len: int
    _bwt_size: int
    _primary: int
    _bwt: ptr[u32]
    _sa: ptr[int]
    _n_sa: int
    _L2: ptr[int]
    _cnt_table: ptr[u32]
    _sa_intv: int
    _bntseq: bntseq

    def __pickle__(self: FMDIndex, jar: Jar):
        pickle(self._seq_len, jar)
        pickle(self._primary, jar)
        pickle(self._sa_intv, jar)
        _pickle_ptr(self._bwt, self._bwt_size, jar)
        _pickle_ptr(self._sa, self._n_sa, jar)
        _pickle_ptr(self._L2, 5, jar)
        _pickle_ptr(self._cnt_table, 256, jar)
        pickle(self._bntseq, jar)

    def __unpickle__(jar: Jar):
        fmi = FMDIndex()
        seq_len = unpickle[int](jar)
        primary = unpickle[int](jar)
        sa_intv = unpickle[int](jar)
        bwt, bwt_size = _unpickle_ptr[u32](jar)
        sa, n_sa = _unpickle_ptr[int](jar)
        L2, _ = _unpickle_ptr[int](jar)
        cnt_table, _ = _unpickle_ptr[u32](jar)
        b = unpickle[bntseq](jar)

        fmi._seq_len = seq_len
        fmi._bwt_size = bwt_size
        fmi._primary = primary
        fmi._bwt = bwt
        fmi._sa = sa
        fmi._n_sa = n_sa
        fmi._L2 = L2
        fmi._cnt_table = cnt_table
        fmi._sa_intv = sa_intv
        fmi._bntseq = b
        return fmi

    def __init__(self: FMDIndex):
        self._seq_len = 0
        self._bwt_size = 0
        self._primary = 0
        self._bwt = ptr[u32]()
        self._sa = ptr[int]()
        self._n_sa = 0
        self._L2 = ptr[int]()
        self._cnt_table = ptr[u32]()
        self._sa_intv = 0
        self._bntseq = None

    def __init__(self: FMDIndex, path: str):
        self._bntseq = bntseq(path)
        self._init_from_enc(self._bntseq._pac, self._bntseq._l_pac)

    def _init_from_enc(self: FMDIndex, p: ptr[u8], l: int):
        from bio.bwt import _saisxx
        def clear[T](p: ptr[T], n: int):
            i = 0
            while i < n:
                p[i] = T()
                i += 1

        def I(b: bool):
            return 1 if b else 0

        len_L2 = 5
        len_count_table = 256
        self._L2 = ptr[int](len_L2)
        clear(self._L2, len_L2)
        self._cnt_table = ptr[u32](len_count_table)
        clear(self._cnt_table, len_count_table)

        # calculate bwt
        self._seq_len = 2*l
        ref_seq = ptr[u8](2*l)
        i = 0
        while i < l:
            b = bntseq.get_pac(p, i)
            self._L2[int(b) + 1] += 1
            ref_seq[i] = b
            i += 1
        i = 0
        while i < l:
            b = u8(3) - ref_seq[l - 1 - i]
            self._L2[int(b) + 1] += 1
            ref_seq[l + i] = b
            i += 1
        l *= 2

        i = 2
        while i < 5:
            self._L2[i] += self._L2[i - 1]
            i += 1

        SA = _saisxx(ptr[byte](ref_seq), l, k=4)

        s = ptr[u8](l + 1)
        clear(s, l + 1)
        i = 0
        while i <= l:
            sa_val = l if i == 0 else SA[i - 1]
            if sa_val == 0:
                self._primary = i
            else:
                s[i] = ref_seq[sa_val - 1]
            i += 1
        _gc.free(ptr[byte](ref_seq))
        _gc.free(ptr[byte](SA))

        i = self._primary
        while i < l:
            s[i] = s[i + 1]
            i += 1

        self._bwt_size = (l + 15) // 16
        self._bwt = ptr[u32](self._bwt_size)
        clear(self._bwt, self._bwt_size)

        i = 0
        while i < l:
            self._bwt[i >> 4] |= u32(int(s[i]) << ((15 - (i & 15)) << 1))
            i += 1
        _gc.free(ptr[byte](s))

        # generate cnt_table
        i = 0
        while i != 256:
            x = 0
            j = 0
            while j != 4:
                x |= (I((i&3) == j) + I((i>>2&3) == j) + I((i>>4&3) == j) + I(i>>6 == j)) << (j<<3)
                j += 1
            self._cnt_table[i] = u32(x)
            i += 1

        self._bwt_update()
        self._cal_sa(32)

    def _bwt_get(self: FMDIndex, k: int):
        # ((b)->bwt[((k)>>7<<4) + sizeof(bwtint_t) + (((k)&0x7f)>>4)])
        return int(self._bwt[(k>>7<<4) + 8 + ((k&0x7f)>>4)])

    def _occ_intv(self: FMDIndex, k: int):
        # ((b)->bwt + ((k)>>7<<4))
        return self._bwt + (k>>7<<4)

    def _B0(self: FMDIndex, k: int):
        # (bwt_bwt(b, k)>>((~(k)&0xf)<<1)&3)
        return self._bwt_get(k) >> ((~k&0xf)<<1) & 3

    def _B00(self: FMDIndex, k: int):
        # ((b)->bwt[(k)>>4]>>((~(k)&0xf)<<1)&3)
        return int(self._bwt[k>>4]) >> ((~k&0xf)<<1) & 3

    # compute inverse CSA
    def _inv_psi(self: FMDIndex, k: int):
        x = k - (1 if k > self._primary else 0)
        x = self._B0(x)
        x = self._L2[x] + self._occ(k, x)
        return 0 if k == self._primary else x

    def _cal_sa(self: FMDIndex, intv: int):
        assert intv > 0 and (intv & (intv - 1)) == 0
        if self._sa:
            _gc.free(ptr[byte](self._sa))
        self._sa_intv = intv
        self._n_sa = (self._seq_len + intv) // intv
        self._sa = ptr[int](_gc.alloc_atomic(self._n_sa * _gc.sizeof[int]()))
        isa = 0
        sa = self._seq_len
        i = 0
        while i < self._seq_len:
            if isa % intv == 0:
                self._sa[isa // intv] = sa
            sa -= 1
            isa = self._inv_psi(isa)
            i += 1
        if isa % intv == 0:
            self._sa[isa // intv] = sa
        self._sa[0] = -1  # before this line, bwt->sa[0] = bwt->seq_len

    def _bwt_update(self: FMDIndex):
        c = __array__[int](4)
        n_occ = (self._seq_len + OCC_INTERVAL - 1) // OCC_INTERVAL + 1
        self._bwt_size += n_occ * 8  # the new size
        buf = ptr[u32](self._bwt_size)  # will be the new bwt
        c[0] = 0
        c[1] = 0
        c[2] = 0
        c[3] = 0
        i = 0
        k = 0
        while i < self._seq_len:
            if i % OCC_INTERVAL == 0:
                str.memcpy(ptr[byte](buf + k), ptr[byte](c.ptr), 4 * 8)
                k += 8  # in fact: sizeof(bwtint_t)=4*(sizeof(bwtint_t)/4)
            if i % 16 == 0:  # 16 == sizeof(uint32_t)/2
                buf[k] = self._bwt[i//16]
                k += 1
            c[self._B00(i)] += 1
            i += 1
        str.memcpy(ptr[byte](buf + k), ptr[byte](c.ptr), 4 * 8)
        assert k + 8 == self._bwt_size
        _gc.free(ptr[byte](self._bwt))
        self._bwt = buf

    def _sa_get(self: FMDIndex, k: int):
        sa = 0
        mask = self._sa_intv - 1
        while k & mask:
            sa += 1
            k = self._inv_psi(k)

        # without setting bwt->sa[0] = -1, the following line should be
        # changed to (sa + bwt->sa[k/bwt->sa_intv]) % (bwt->seq_len + 1)
        return sa + self._sa[k // self._sa_intv]

    def __occ_aux(y: int, c: int):
        # reduce nucleotide counting to bits counting
        y = (y if c&2 else ~y) >> 1 & (y if c&1 else ~y) & 0x5555555555555555
        # count the number of 1s in y
        y = (y & 0x3333333333333333) + (y >> 2 & 0x3333333333333333)
        return ((y + (y >> 4)) & 0xf0f0f0f0f0f0f0f) * 0x101010101010101 >> 56

    def _occ(self: FMDIndex, k: int, c: int):
        if k == self._seq_len:
            return self._L2[c + 1] - self._L2[c]
        if k < 0:
            return 0
        k -= 1 if k >= self._primary else 0  # because $ is not in bwt

        # retrieve Occ at k/OCC_INTERVAL
        p = self._occ_intv(k)
        n = ptr[int](p)[c]
        p += 8  # jump to the start of the first FMDIndex cell

        # calculate Occ up to the last k/32
        end = p + (((k>>5) - ((k&~OCC_INTV_MASK)>>5))<<1)
        while p < end:
            n += FMDIndex.__occ_aux(int(p[0])<<32 | int(p[1]), c)
            p += 2

        # calculate Occ
        n += FMDIndex.__occ_aux((int(p[0])<<32 | int(p[1])) & ~((1<<((~k&31)<<1)) - 1), c)
        if c == 0: n -= ~k&31  # corrected for the masked bits

        return n

    # an analogy to bwt_occ() but more efficient, requiring k <= l
    def _2occ(self: FMDIndex, k: int, l: int, c: int):
        _k = k - 1 if k >= self._primary else k
        _l = l - 1 if l >= self._primary else l
        if _l // OCC_INTERVAL != _k // OCC_INTERVAL or k < 0 or l < 0:
            return self._occ(k, c), self._occ(l, c)
        else:
            if k >= self._primary: k -= 1
            if l >= self._primary: l -= 1
            p = self._occ_intv(k)
            n = ptr[int](p)[c]
            p += 8
            # calculate ok
            j = k >> 5 << 5
            i = k // OCC_INTERVAL * OCC_INTERVAL
            while i < j:
                n += FMDIndex.__occ_aux(int(p[0])<<32 | int(p[1]), c)
                i += 32
                p += 2
            m = n
            n += FMDIndex.__occ_aux((int(p[0])<<32 | int(p[1])) & ~((1<<((~k&31)<<1)) - 1), c)
            if c == 0: n -= ~k&31  # corrected for the masked bits
            ok = n
            # calculate ol
            j = l >> 5 << 5
            while i < j:
                m += FMDIndex.__occ_aux(int(p[0])<<32 | int(p[1]), c)
                i += 32
                p += 2
            m += FMDIndex.__occ_aux((int(p[0])<<32 | int(p[1])) & ~((1<<((~l&31)<<1)) - 1), c)
            if c == 0: m -= ~l&31  # corrected for the masked bits
            ol = m
            return ok, ol

    def __occ_aux4(self: FMDIndex, b: int):
        C = self._cnt_table
        return int(C[b&0xff] + C[b>>8&0xff] + C[b>>16&0xff] + C[b>>24])

    def _occ4(self: FMDIndex, k: int):
        cnt = __array__[int](4)
        if k < 0:
            return 0, 0, 0, 0
        k -= 1 if k >= self._primary else 0
        p = self._occ_intv(k)
        str.memcpy(ptr[byte](cnt.ptr), ptr[byte](p), 4 * 8)
        p += 8
        end = p + ((k>>4) - ((k&~OCC_INTV_MASK)>>4))  # this is the end point of the following loop
        x = 0
        while p < end:
            x += self.__occ_aux4(int(p[0]))
            p += 1
        tmp = int(p[0] & ~((u32(1)<<u32((~k&15)<<1)) - u32(1)))
        x += self.__occ_aux4(tmp) - (~k&15)
        cnt[0] += x&0xff
        cnt[1] += x>>8&0xff
        cnt[2] += x>>16&0xff
        cnt[3] += x>>24
        return cnt[0], cnt[1], cnt[2], cnt[3]

    # an analogy to bwt_occ4() but more efficient, requiring k <= l
    def _2occ4(self: FMDIndex, k: int, l: int):
        cntk = __array__[int](4)
        cntl = __array__[int](4)
        _k = k - 1 if k >= self._primary else k
        _l = l - 1 if l >= self._primary else l
        if _l >> OCC_INTV_SHIFT != _k >> OCC_INTV_SHIFT or k < 0 or l < 0:
            return self._occ4(k), self._occ4(l)
        else:
            k -= 1 if k >= self._primary else 0
            l -= 1 if l >= self._primary else 0
            p = self._occ_intv(k)
            str.memcpy(ptr[byte](cntk.ptr), ptr[byte](p), 4 * 8)
            p += 8
            # prepare cntk[]
            endk = p + ((k>>4) - ((k&~OCC_INTV_MASK)>>4))
            endl = p + ((l>>4) - ((l&~OCC_INTV_MASK)>>4))
            x = 0
            while p < endk:
                x += self.__occ_aux4(int(p[0]))
                p += 1
            y = x
            tmp = int(p[0] & ~((u32(1)<<u32((~k&15)<<1)) - u32(1)))
            x += self.__occ_aux4(tmp) - (~k&15)
            # calculate cntl[] and finalize cntk[]
            while p < endl:
                y += self.__occ_aux4(int(p[0]))
                p += 1
            tmp = int(p[0] & ~((u32(1)<<u32((~l&15)<<1)) - u32(1)))
            y += self.__occ_aux4(tmp) - (~l&15)
            str.memcpy(ptr[byte](cntl.ptr), ptr[byte](cntk.ptr), 4 * 8)
            cntk[0] += x&0xff
            cntk[1] += x>>8&0xff
            cntk[2] += x>>16&0xff
            cntk[3] += x>>24
            cntl[0] += y&0xff
            cntl[1] += y>>8&0xff
            cntl[2] += y>>16&0xff
            cntl[3] += y>>24
            return (cntk[0], cntk[1], cntk[2], cntk[3]), (cntl[0], cntl[1], cntl[2], cntl[3])

    def _match_exact(self: FMDIndex, s: seq):
        k = 0
        l = self._seq_len
        i = len(s) - 1
        while i >= 0:
            c = _enc(s._at(i))
            if c > 3:
                return FMInterval.invalid()
            ok, ol = self._2occ(k - 1, l, c)
            k = self._L2[c] + ok + 1
            l = self._L2[c] + ol
            if k > l:
                break
            i -= 1
        if k > l:
            return -1, -2
        return FMInterval(k, l)

    def occ(self: FMDIndex, k: int, c: seq):
        if len(c) != 1:
            raise ValueError("occ() expects length-1 sequence argument")
        return self._occ1(k, _enc(c._at(0)))

    def less(self: FMDIndex, c: seq):
        if len(c) != 1:
            raise ValueError("less() expects length-1 sequence argument")
        b = _enc(c._at(0))
        if b > 3:
            return -1
        return self._L2[b + 1]

    def interval(self: FMDIndex, c: seq):
        if len(c) != 1:
            raise ValueError("interval() expects length-1 sequence argument")
        b = _enc(c._at(0))
        if b > 3:
            return FMInterval.invalid()
        c0 = self._L2[b] + 1
        c1 = self._L2[b + 1]
        return FMInterval(c0, c1)

    def biinterval(self: FMDIndex, c: seq):
        b = _enc(c._at(0))
        if b > 3:
            return FMDInterval.invalid()
        x0 = int(self._L2[b]) + 1
        x1 = int(self._L2[3 - b]) + 1
        x2 = int(self._L2[b + 1] - self._L2[b])
        return FMDInterval(x0, x1, x2, 0)

    def smems(self: FMDIndex,
              q: seq,
              x: int = 0,
              min_intv: int = 1,
              max_intv: int = 0,
              mem: list[FMDInterval] = None,
              prev: list[FMDInterval] = None,
              curr: list[FMDInterval] = None):
        return smems(self, q, x, min_intv, max_intv, mem, prev, curr)

    def update(self: FMDIndex, intv: FMInterval, c: seq):
        if len(c) != 1:
            raise ValueError("update() expects length-1 sequence argument")
        b = _enc(c._at(0))
        if b > 3:
            return FMInterval.invalid()

        k, l = intv
        ok, ol = self._2occ(k - 1, l, b)
        k = self._L2[b] + ok + 1
        l = self._L2[b] + ol
        return FMInterval(k, l)

    def __getitem__(self: FMDIndex, x: tuple[FMInterval, seq]):
        return self.update(x[0], x[1])

    '''
    def __prefetch__(self: FMDIndex, x: tuple[FMInterval, seq]):
        # TODO
        pass
    '''

    def _get_interval(self: FMDIndex, s: seq):
        if not s:
            return FMInterval.invalid()
        intv = self.interval(s[-1])
        i = len(s) - 2
        while i >= 0 and intv:
            intv = self.update(intv, s[i])
            i -= 1
        return intv

    def __getitem__(self: FMDIndex, intv: FMInterval):
        lo, hi = intv
        while lo <= hi:
            yield int(self._sa_get(lo))
            lo += 1

    def __getitem__(self: FMDIndex, s: seq):
        return self[self._get_interval(s)]

    def results(self: FMDIndex, intv: FMInterval, both_strands=False):
        lo, hi = intv
        while lo <= hi:
            pos, is_rev = self._bntseq.depos(self._sa_get(lo))
            if not is_rev or both_strands:
                rid = self._bntseq.pos2rid(pos)
                ann = self._bntseq._anns[rid]
                yield (rid, ann._name, pos - ann._offset, is_rev)
            lo += 1

    def biresults(self: FMDIndex, intv: FMDInterval):
        lo, lo_rev, size, _ = intv
        hi = lo + size - 1
        l = intv.match_size
        while lo <= hi:
            pos, is_rev = self._bntseq.depos(self._sa_get(lo))
            if is_rev:
                pos -= l - 1
            rid = self._bntseq.pos2rid(pos)
            ann = self._bntseq._anns[rid]
            yield (rid, ann._name, pos - ann._offset, is_rev)
            lo += 1

    def locate(self: FMDIndex, s: seq, both_strands=False):
        return self.results(self._get_interval(s), both_strands)

    def sequence(self: FMDIndex, start: int, stop: int, rid: int = -1, name: str = ''):
        if rid >= 0 and name:
            raise ValueError("cannot specify both 'rid' and 'name' in call to sequence()")

        ann: bntann = None
        if rid >= 0:
            ann = self._bntseq._anns[rid]
        else:
            for a in self._bntseq._anns:
                if a._name == name:
                    ann = a
                    break
            if ann is None:
                raise ValueError(f"no annotation with name {repr(name)}")

        startx, stopx, stepx, lenx = slice.adjust_indices(length=ann._len, start=start, stop=stop)
        startx += ann._offset
        stopx += ann._offset
        return self._bntseq.get_seq(startx, stopx)

    def contigs(self: FMDIndex):
        for ann in self._bntseq._anns:
            yield (ann._name, ann._len)

    def contig(self: FMDIndex, rid: int):
        ann = self._bntseq._anns[rid]
        return (ann._name, ann._len)

class FMIndex:
    _seq_len: int
    _bwt_size: int
    _n_occ: int
    _primary: int
    _bwt: ptr[u32]
    _occ: ptr[u32]
    _sa: ptr[u32]
    _L2: ptr[u32]
    _cnt_table: ptr[u32]
    _FMD: bool
    _bntseq: bntseq

    def __pickle__(self: FMIndex, jar: Jar):
        if not self._bntseq:
            raise ValueError("can only pickle FASTA-based FM-index")
        pickle(self._primary, jar)
        _pickle_ptr(self._bwt, self._bwt_size, jar)
        _pickle_ptr(self._occ, self._n_occ, jar)
        _pickle_ptr(self._sa, (2 if self._FMD else 1)*self._seq_len + 1, jar)
        _pickle_ptr(self._L2, 5, jar)
        _pickle_ptr(self._cnt_table, 256, jar)
        pickle(self._FMD, jar)
        pickle(self._bntseq, jar)

    def __unpickle__(jar: Jar):
        fmi = FMIndex()
        primary = unpickle[int](jar)
        bwt, bwt_size = _unpickle_ptr[u32](jar)
        occ, n_occ = _unpickle_ptr[u32](jar)
        sa, seq_len_p1 = _unpickle_ptr[u32](jar)
        seq_len = seq_len_p1 - 1
        L2, _ = _unpickle_ptr[u32](jar)
        cnt_table, _ = _unpickle_ptr[u32](jar)
        FMD = unpickle[bool](jar)
        b = unpickle[bntseq](jar)

        fmi._seq_len = seq_len
        fmi._bwt_size = bwt_size
        fmi._n_occ = n_occ
        fmi._primary = primary
        fmi._bwt = bwt
        fmi._occ = occ
        fmi._sa = sa
        fmi._L2 = L2
        fmi._cnt_table = cnt_table
        fmi._FMD = FMD
        fmi._bntseq = b
        return fmi

    def _B0(self: FMIndex, k: int):
        return int(self._bwt[k >> 4] >> u32(((~k & 0xf) << 1)) & u32(3))

    def _init_from_enc(self: FMIndex, p: ptr[u8], l: int, packed: bool = False, FMD: bool = False):
        from bio.bwt import _saisxx
        def clear[T](p: ptr[T], n: int):
            i = 0
            while i < n:
                p[i] = T()
                i += 1

        def I(b: bool):
            return 1 if b else 0

        if (2*l if FMD else l) >= 0xffffffff:
            raise ValueError("sequence is too long for FM-index!")

        assert not (FMD and not packed)
        len_L2 = 5
        len_count_table = 256
        self._L2 = ptr[u32](len_L2)
        clear(self._L2, len_L2)
        self._cnt_table = ptr[u32](len_count_table)
        clear(self._cnt_table, len_count_table)

        # calculate bwt
        self._seq_len = l

        ref_seq = ptr[u8](2*l if FMD else l) if packed else p
        if packed:
            i = 0
            while i < l:
                ref_seq[i] = bntseq.get_pac(p, i)
                i += 1
            if FMD:
                i = 0
                while i < l:
                    ref_seq[l + i] = u8(3) - ref_seq[l - 1 - i]
                    i += 1
                l *= 2

        self._sa = ptr[u32](l + 1)
        self._sa[0] = u32(l)
        SA = _saisxx(ptr[byte](ref_seq), l, k=4)
        i = 0
        while i < l:
            self._sa[i + 1] = u32(SA[i])
            i += 1
        _gc.free(ptr[byte](SA))

        s = ptr[u8](l + 1)
        clear(s, l + 1)
        i = 0
        while i <= l:
            if self._sa[i] == u32(0):
                self._primary = i
            else:
                s[i] = ref_seq[int(self._sa[i]) - 1]
            i += 1
        if packed:
            _gc.free(ptr[byte](ref_seq))

        i = self._primary
        while i < l:
            s[i] = s[i + 1]
            i += 1

        self._bwt_size = (l + 15) // 16
        self._bwt = ptr[u32](self._bwt_size)
        clear(self._bwt, self._bwt_size)

        i = 0
        while i < l:
            self._bwt[i >> 4] |= u32(int(s[i]) << ((15 - (i & 15)) << 1))
            i += 1
        _gc.free(ptr[byte](s))

        # calculate occ
        c = __array__[u32](4)
        c[0] = u32(0)
        c[1] = u32(0)
        c[2] = u32(0)
        c[3] = u32(0)
        self._n_occ = (l + 15) // 16 * 4
        self._occ = ptr[u32](self._n_occ)
        clear(self._occ, self._n_occ)

        i = 0
        while i < l:
            if i % 16 == 0:
                str.memcpy(ptr[byte](self._occ + (i//16) * 4), ptr[byte](c.ptr), 16)
            c[self._B0(i)] += u32(1)
            i += 1

        str.memcpy(ptr[byte](self._L2 + 1), ptr[byte](c.ptr), 16)

        i = 2
        while i < 5:
            self._L2[i] += self._L2[i - 1]
            i += 1

        # generate cnt_table
        i = 0
        while i != 256:
            x = 0
            j = 0
            while j != 4:
                x |= (I((i&3) == j) + I((i>>2&3) == j) + I((i>>4&3) == j) + I(i>>6 == j)) << (j<<3)
                j += 1
            self._cnt_table[i] = u32(x)
            i += 1

        self._FMD = FMD

    def __init__(self: FMIndex):
        self._seq_len = 0
        self._bwt_size = 0
        self._n_occ = 0
        self._primary = 0
        self._bwt = ptr[u32]()
        self._occ = ptr[u32]()
        self._sa = ptr[u32]()
        self._L2 = ptr[u32]()
        self._cnt_table = ptr[u32]()
        self._bntseq = None
        self._FMD = False

    def __init__(self: FMIndex, s: seq):
        if s.N():
            raise ValueError("cannot build FM-index for sequence containing ambiguous bases")
        n = len(s)
        p = ptr[byte](n)
        if s.len > 0:
            i = 0
            while i < n:
                p[i] = byte(_enc(s.ptr[i]))
                i += 1
        else:
            i = n - 1
            while i >= 0:
                p[n - 1 - i] = byte(3 - _enc(s.ptr[i]))
                i -= 1

        self._init_from_enc(ptr[u8](p), n, FMD=False, packed=False)
        _gc.free(p)
        self._bntseq = None

    def __init__(self: FMIndex, path: str):
        self._bntseq = bntseq(path)
        self._init_from_enc(self._bntseq._pac, self._bntseq._l_pac, FMD=False, packed=True)

    def __init__(self: FMIndex, path: str, FMD: bool):
        self._bntseq = bntseq(path)
        self._init_from_enc(self._bntseq._pac, self._bntseq._l_pac, FMD=FMD, packed=True)

    def _occ1(self: FMIndex, k: int, c: int):
        if k >= self._seq_len:
            return int(self._L2[c + 1] - self._L2[c])
        if k < 0:
            return 0
        if k >= self._primary:
            k -= 1
        n = self._occ[k//16<<2|c]
        b = int(self._bwt[k//16] & ~((u32(1) << u32(((15-(k&15))<<1))) - u32(1)))
        n += (self._cnt_table[b&0xff] + self._cnt_table[b>>8&0xff] + self._cnt_table[b>>16&0xff] + self._cnt_table[b>>24]) >> u32(c<<3) & u32(0xff)
        if c == 0:
            n -= u32(15 - (k&15))
        return int(n)

    def _occ4(self: FMIndex, k: int):
        if k < 0:
            return 0, 0, 0, 0
        if k >= self._primary:
            k -= 1
        cnt = __array__[u32](4)
        str.memcpy(ptr[byte](cnt.ptr), ptr[byte](self._occ + (k >> 4 << 2)), 16)
        b = int(self._bwt[k >> 4] & ~((u32(1) << u32((~k&15) << 1)) - u32(1)))
        x = self._cnt_table[b & 0xff] + self._cnt_table[b >> 8 & 0xff] + self._cnt_table[b >> 16 & 0xff] + self._cnt_table[b >> 24]
        x -= u32(15 - (k & 15))
        cnt[0] += x & u32(0xff)
        cnt[1] += x >> u32(8) & u32(0xff)
        cnt[2] += x >> u32(16) & u32(0xff)
        cnt[3] += x >> u32(24)
        return int(cnt[0]), int(cnt[1]), int(cnt[2]), int(cnt[3])

    def _2occ4(self: FMIndex, k: int, l: int):
        return (self._occ4(k), self._occ4(l))

    def occ(self: FMIndex, k: int, c: seq):
        if len(c) != 1:
            raise ValueError("occ() expects length-1 sequence argument")
        return self._occ1(k, _enc(c._at(0)))

    def less(self: FMDIndex, c: seq):
        if len(c) != 1:
            raise ValueError("less() expects length-1 sequence argument")
        b = _enc(c._at(0))
        if b > 3:
            return -1
        return self._L2[b + 1]

    def interval(self: FMIndex, c: seq):
        if len(c) != 1:
            raise ValueError("interval() expects length-1 sequence argument")
        b = _enc(c._at(0))
        if b > 3:
            return FMInterval.invalid()
        c0 = int(self._L2[b]) + 1
        c1 = int(self._L2[b + 1])
        return FMInterval(c0, c1)

    def _fmd_check(self: FMIndex):
        if not self._FMD:
            raise ValueError("FMIndex instance is not FMD-index")

    def biinterval(self: FMIndex, c: seq):
        self._fmd_check()
        b = _enc(c._at(0))
        if b > 3:
            return FMDInterval.invalid()
        x0 = int(self._L2[b]) + 1
        x1 = int(self._L2[3 - b]) + 1
        x2 = int(self._L2[b + 1] - self._L2[b])
        return FMDInterval(x0, x1, x2, 0)

    def smems(self: FMIndex,
              q: seq,
              x: int = 0,
              min_intv: int = 1,
              max_intv: int = 0,
              mem: list[FMDInterval] = None,
              prev: list[FMDInterval] = None,
              curr: list[FMDInterval] = None):
        return smems(self, q, x, min_intv, max_intv, mem, prev, curr)

    def update(self: FMIndex, intv: FMInterval, c: seq):
        if len(c) != 1:
            raise ValueError("update() expects length-1 sequence argument")
        b = _enc(c._at(0))
        if b > 3:
            return FMInterval.invalid()
        lo, hi = intv
        c0 = int(self._L2[b])
        occ1 = self._occ1(lo - 1, b)
        occ2 = self._occ1(hi, b)
        return FMInterval(c0 + occ1 + 1, c0 + occ2)

    def __getitem__(self: FMIndex, x: tuple[FMInterval, seq]):
        return self.update(x[0], x[1])

    def __prefetch__(self: FMIndex, x: tuple[FMInterval, seq]):
        intv, c = x
        assert len(c) == 1
        lo, hi = intv
        b = _enc(c._at(0))
        k1 = lo - 1
        k2 = hi
        if k1 >= self._primary:
            k1 -= 1
        if k2 >= self._primary:
            k2 -= 1

        (self._occ + (k1//16<<2|b)).__prefetch_r0__()
        (self._occ + (k2//16<<2|b)).__prefetch_r0__()
        (self._bwt + (k1//16)).__prefetch_r0__()
        (self._bwt + (k2//16)).__prefetch_r0__()

    def _get_interval(self: FMIndex, s: seq):
        if not s:
            return FMInterval(0, -1)
        intv = self.interval(s[-1])
        i = len(s) - 2
        while i >= 0 and intv:
            intv = self.update(intv, s[i])
            i -= 1
        return intv

    def __getitem__(self: FMIndex, intv: FMInterval):
        lo, hi = intv
        while lo <= hi:
            yield int(self._sa[lo])
            lo += 1

    def __getitem__(self: FMIndex, s: seq):
        return self[self._get_interval(s)]

    def count(self: FMIndex, s: seq):
        return len(self._get_interval(s))

    def results(self: FMIndex, intv: FMInterval):
        if self._bntseq is None:
            raise ValueError("results() requires FASTA-based FM-index")
        lo, hi = intv
        fmd = self._FMD
        while lo <= hi:
            pos = int(self._sa[lo])
            if self._FMD and pos >= self._bntseq._l_pac:
                continue
            rid = self._bntseq.pos2rid(pos)
            ann = self._bntseq._anns[rid]
            yield (rid, ann._name, pos - ann._offset)
            lo += 1

    def biresults(self: FMIndex, intv: FMDInterval):
        self._fmd_check()
        if self._bntseq is None:
            raise ValueError("biresults() requires FASTA-based FM-index")
        lo, lo_rev, size, _ = intv
        hi = lo + size - 1
        l = intv.match_size
        while lo <= hi:
            pos, is_rev = self._bntseq.depos(int(self._sa[lo]))
            if is_rev:
                pos -= l - 1
            rid = self._bntseq.pos2rid(pos)
            ann = self._bntseq._anns[rid]
            yield (rid, ann._name, pos - ann._offset, is_rev)
            lo += 1

    def locate(self: FMIndex, s: seq):
        if self._bntseq is None:
            raise ValueError("locate() requires FASTA-based FM-index")
        return self.results(self._get_interval(s))

    def sequence(self: FMIndex, start: int, stop: int, rid: int = -1, name: str = ''):
        if self._bntseq is None:
            raise ValueError("sequence() requires FASTA-based FM-index")
        if rid >= 0 and name:
            raise ValueError("cannot specify both 'rid' and 'name' in call to sequence()")

        ann: bntann = None
        if rid >= 0:
            ann = self._bntseq._anns[rid]
        else:
            for a in self._bntseq._anns:
                if a._name == name:
                    ann = a
                    break
            if ann is None:
                raise ValueError(f"no annotation with name {repr(name)}")

        startx, stopx, stepx, lenx = slice.adjust_indices(length=ann._len, start=start, stop=stop)
        startx += ann._offset
        stopx += ann._offset
        return self._bntseq.get_seq(startx, stopx)

    def contigs(self: FMIndex):
        if self._bntseq is None:
            raise ValueError("contigs() requires FASTA-based FM-index")
        for ann in self._bntseq._anns:
            yield (ann._name, ann._len)

    def contig(self: FMDIndex, rid: int):
        ann = self._bntseq._anns[rid]
        return (ann._name, ann._len)
