LD = "/usr/local/Cellar/python/3.7.4_1/Frameworks/Python.framework/Versions/3.7/lib/libpython3.7m.dylib"

from C import dlopen, DLException
try:
    dlopen(LD)
except DLException:
    LD = "\0" + LD

from LD cimport PyUnicode_AsEncodedString(cobj, cobj, cobj) -> cobj
from LD cimport PyBytes_AsString(cobj) -> cobj
from LD cimport PyErr_Fetch(ptr[cobj], ptr[cobj], ptr[cobj])
from LD cimport PyObject_GetAttrString(cobj, cobj) -> cobj
from LD cimport PyObject_Str(cobj) -> cobj
from LD cimport PyRun_SimpleString(cobj)
from LD cimport Py_IncRef(cobj)
from LD cimport Py_DecRef(cobj)
from LD cimport PyObject_CallObject(cobj, cobj) -> cobj
from LD cimport PyObject_SetAttrString(cobj, cobj, cobj) -> cobj
from LD cimport PyObject_Length(cobj) -> int
from LD cimport Py_Initialize()
from LD cimport PyImport_ImportModule(cobj) -> cobj
from LD cimport PyLong_FromLong(int) -> cobj
from LD cimport PyLong_AsLong(cobj) -> int
from LD cimport PyFloat_FromDouble(float) -> cobj
from LD cimport PyFloat_AsDouble(cobj) -> float
from LD cimport PyBool_FromLong(int) -> cobj
from LD cimport PyObject_IsTrue(cobj) -> int
from LD cimport PyUnicode_DecodeFSDefaultAndSize(cobj, int) -> cobj
from LD cimport PyTuple_New(int) -> cobj
from LD cimport PyTuple_SetItem(cobj, int, cobj)
from LD cimport PyTuple_GetItem(cobj, int) -> cobj
from LD cimport PyList_New(int) -> cobj
from LD cimport PyList_SetItem(cobj, int, cobj) -> cobj
from LD cimport PyList_GetItem(cobj, int) -> cobj
from LD cimport PySet_New(cobj) -> cobj
from LD cimport PySet_Add(cobj, cobj) -> cobj
from LD cimport PyDict_New() -> cobj
from LD cimport PyDict_SetItem(cobj, cobj, cobj) -> cobj
from LD cimport PyDict_Next(cobj, ptr[int], ptr[cobj], ptr[cobj]) -> int

class PyException:
    msg: str
    pytype: str

type pyobj(p: ptr[byte]):
    def to_str(self: pyobj, errors: str, empty: str = "") -> str:
        obj = PyUnicode_AsEncodedString(self.p, "utf-8".c_str(), errors.c_str())
        if obj == cobj():
            return empty
        bts = PyBytes_AsString(obj)
        pyobj(obj).decref()
        return str.from_ptr(bts)

    def exc_check():
        ptype, pvalue, ptraceback = cobj(), cobj(), cobj()
        PyErr_Fetch(__ptr__(ptype), __ptr__(pvalue), __ptr__(ptraceback))
        if ptype != cobj():
            py_msg = PyObject_Str(pvalue) if pvalue != cobj() else pvalue
            msg = pyobj(py_msg).to_str("ignore", "<empty Python message>")
            typ = pyobj.to_str(pyobj(PyObject_GetAttrString(ptype, "__name__".c_str())), "ignore")

            pyobj(ptype).decref()
            pyobj(pvalue).decref()
            pyobj(ptraceback).decref()
            pyobj(py_msg).decref()

            raise PyException(msg, typ)

    def exc_wrap(_retval):
        pyobj.exc_check()
        return _retval

    def incref(self: pyobj):
        Py_IncRef(self.p)

    def decref(self: pyobj):
        Py_DecRef(self.p)

    def call(self: pyobj, args : optional[pyobj] = None):
        args_py = (~args).p if args else cobj()
        return pyobj.exc_wrap(pyobj(PyObject_CallObject(self.p, args_py)))

    def __getitem__(self: pyobj, name: str):
        return pyobj.exc_wrap(pyobj(PyObject_GetAttrString(self.p, name.c_str())))

    def __setitem__(self: pyobj, name: str, val: pyobj):
        return pyobj.exc_wrap(pyobj(PyObject_SetAttrString(self.p, name.c_str(), val.p)))

    def __len__(self: pyobj):
        return pyobj.exc_wrap(PyObject_Length(self.p))

    def __to_py__(self: pyobj):
        return self

def init():
    Py_Initialize()
if LD.__len__() == 0 or LD[0] != "\0":
    init()

def none():
    #cimport seq_py_none() -> ptr[byte]
    #return pyobj(seq_py_none())
    raise PyException("not yet done", "n/a")

def imp(name: str) -> pyobj:
    return pyobj.exc_wrap(pyobj(PyImport_ImportModule(name.c_str())))

def exec(code: str):
    PyRun_SimpleString(code.c_str())

# conversions

def py(x) -> pyobj:
    return x.__to_py__()

def get[T](x: pyobj) -> T:
    return T.__from_py__(x)

extend int:
    def __to_py__(self: int) -> pyobj:
        return pyobj.exc_wrap(pyobj(PyLong_FromLong(self)))

    def __from_py__(i: pyobj):
        return pyobj.exc_wrap(PyLong_AsLong(i.p))

extend float:
    def __to_py__(self: float) -> pyobj:
        return pyobj.exc_wrap(pyobj(PyFloat_FromDouble(self)))

    def __from_py__(d: pyobj):
        return pyobj.exc_wrap(PyFloat_AsDouble(d.p))

extend bool:
    def __to_py__(self: bool) -> pyobj:
        return pyobj.exc_wrap(pyobj(PyBool_FromLong(int(self))))

    def __from_py__(b: pyobj):
        return pyobj.exc_wrap(PyObject_IsTrue(b.p)) != 0

extend byte:
    def __to_py__(self: byte) -> pyobj:
        return str.__to_py__(str(__ptr__(self), 1))

    def __from_py__(c: pyobj):
        return str.__from_py__(c).p[0]

extend str:
    def __to_py__(self: str) -> pyobj:
        return pyobj.exc_wrap(pyobj(PyUnicode_DecodeFSDefaultAndSize(self.ptr, self.len)))

    def __from_py__(s: pyobj):
        r = s.to_str("strict")
        pyobj.exc_check()
        return r

extend seq:
    def __to_py__(self: seq) -> pyobj:
        return str(self).__to_py__()

    def __from_py__(s: pyobj) -> seq:
        return seq(str.__from_py__(s))

# We need cobjs here for LLVM to access them easily

def py_tuple_new(len: int) -> cobj:
    t = PyTuple_New(len)
    pyobj.exc_check()
    return t
_force_py_tuple_new = py_tuple_new

def py_tuple_setitem(obj: cobj, idx: int, val: cobj):
    PyTuple_SetItem(obj, idx, val)
    pyobj.exc_check()
_force_py_tuple_setitem = py_tuple_setitem

def py_tuple_getitem(obj: cobj, idx: int) -> cobj:
    t = PyTuple_GetItem(obj, idx)
    pyobj.exc_check()
    return t
_force_py_tuple_getitem = py_tuple_getitem
