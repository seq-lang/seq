from algorithms.timsort import tim_sort_inplace
from algorithms.pdqsort import pdq_sort_inplace
from algorithms.insertionsort import insertion_sort_inplace
from algorithms.heapsort import heap_sort_inplace
from algorithms.qsort import qsort_inplace

def sorted[T,S=None](
    v: Generator[T],
    key: Optional[Callable[S,T]] = None,
    algorithm: Optional[str] = None,
    reverse: bool = False
):
    """
    Return a sorted list of the elements in v
    """
    newlist = [a for a in v]
    if not isinstance(S, None):
        if algorithm:
            newlist.sort(~key, ~algorithm, reverse)
        else:
            newlist.sort(~key, None, reverse)
    else:
        if algorithm:
            newlist.sort(None, ~algorithm, reverse)
        else:
            newlist.sort(None, None, reverse)
    return newlist

def _sort_list[T,S](self, key: Callable[S,T], algorithm: str):
    if algorithm == 'pdq':
        pdq_sort_inplace(self, key)
    elif algorithm == 'insertion':
        insertion_sort_inplace(self, key)
    elif algorithm == 'heap':
        heap_sort_inplace(self, key)
        #case 'tim':
        #    tim_sort_inplace(self, key)
    elif algorithm == 'quick':
        qsort_inplace(self, key)
    else:
        raise ValueError("Algorithm '" + algorithm + "' does not exist")

@extend
class List[T]:
    def sort[S=None](
        self,
        key: Optional[Callable[S,T]] = None,
        algorithm: Optional[str] = None,
        reverse: bool = False
    ):
        alg = ~algorithm if algorithm else 'pdq'
        if isinstance(S, None):
            def id(x: T) -> T: return x
            _sort_list(self, id, alg)
        else:
            assert key
            _sort_list(self, ~key, alg)
        if reverse:
            self.reverse()
